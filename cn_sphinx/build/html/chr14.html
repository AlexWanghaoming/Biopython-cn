<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第14章 使用Bio.motifs进行模体序列分析 &mdash; biopython_cn 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="biopython_cn 0.1 documentation" href="index.html" />
    <link rel="next" title="第15章 聚类分析" href="chr15.html" />
    <link rel="prev" title="第13章 Bio.Phylo系统发育分析" href="chr13.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chr15.html" title="第15章 聚类分析"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chr13.html" title="第13章 Bio.Phylo系统发育分析"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="bio-motifs">
<h1>第14章   使用Bio.motifs进行模体序列分析<a class="headerlink" href="#bio-motifs" title="Permalink to this headline">¶</a></h1>
<p>这章主要的介绍Biopython中的 <tt class="docutils literal"><span class="pre">Bio.motifs</span></tt> 包。这个包是为了方便那些需要进行模体序列分析的人们而特意提供的，所以我想你们在使用时肯定对模体序列分析的一些相关要点都很熟悉。假如在使用中遇到不清楚的地方，请您查阅 <a class="reference internal" href="#sec-links"><em>14.8</em></a> 相关章节以获得有关的信息。</p>
<p>这章的大部分内容是介绍Biopython 1.61 之前版本中新加入的 <tt class="docutils literal"><span class="pre">Bio.motifs</span></tt> 包，该包替代了Biopython 1.50版本中的 <tt class="docutils literal"><span class="pre">Bio.Motif</span></tt> 包，而 <tt class="docutils literal"><span class="pre">Bio.Motif</span></tt> 包是基于较早版本的Biopython 中的两个模块 <tt class="docutils literal"><span class="pre">Bio.AlignAce</span></tt> 和 <tt class="docutils literal"><span class="pre">Bio.MEME</span></tt> 。<tt class="docutils literal"><span class="pre">Bio.motifs</span></tt> 包较好地综合了上述的几个模块的功能，做为一个统一模块工具。</p>
<p>说到其他库，看到这里，你或许会对 <a class="reference external" href="http://fraenkel.mit.edu/TAMO/">TAMO</a> 感兴趣，这是另一个分析模体序列的Python库。它能提供更多关于 <em>de-novo</em> 模体的查找方式，不过它并没有纳入到Biopython中，而且在商业用途上还有一些限制。</p>
<div class="section" id="id1">
<h2>14.1  模体对象<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>由于我们感兴趣的是模体分析，所以我们需要先看看 <tt class="docutils literal"><span class="pre">Motif</span></tt> 对象。对此我们需要先导入Bio.motifs包：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">motifs</span>
</pre></div>
</div>
<p>然后我们可以开始创建我们第一个模体对象。我们可以从模体的实例列表中创建一个 <tt class="docutils literal"><span class="pre">Motif</span></tt> 对象，也可以通过读取模体数据库中或模体查找软件产生的文件来获得一个 <tt class="docutils literal"><span class="pre">Motif</span></tt> 对象。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">motifs</span>
</pre></div>
</div>
<div class="section" id="id2">
<h3>14.1.1  从实例中创建一个模体<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>假设我们有一些DNA模体的实例：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instances</span> <span class="o">=</span> <span class="p">[</span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TACAA&quot;</span><span class="p">),</span>
<span class="gp">... </span>             <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TACGC&quot;</span><span class="p">),</span>
<span class="gp">... </span>             <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TACAC&quot;</span><span class="p">),</span>
<span class="gp">... </span>             <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TACCC&quot;</span><span class="p">),</span>
<span class="gp">... </span>             <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AACCC&quot;</span><span class="p">),</span>
<span class="gp">... </span>             <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AATGC&quot;</span><span class="p">),</span>
<span class="gp">... </span>             <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AATGC&quot;</span><span class="p">),</span>
<span class="gp">... </span>            <span class="p">]</span>
</pre></div>
</div>
<p>然后我们可以如下创建一个模体对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">instances</span><span class="p">)</span>
</pre></div>
</div>
<p>这些实例被存储在一个名为 <tt class="docutils literal"><span class="pre">m.instances</span></tt> 的属性中，这个其实也就是一个Python的列表，只不过附加了一些功能，这些功能将在之后介绍。将这些模体对象打印出来后就可以看出这些实例是从哪构建出来的。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">m</span>
<span class="go">TACAA</span>
<span class="go">TACGC</span>
<span class="go">TACAC</span>
<span class="go">TACCC</span>
<span class="go">AACCC</span>
<span class="go">AATGC</span>
<span class="go">AATGC</span>
</pre></div>
</div>
<p>模体的长度像其他一些实例一些被定义为序列的长度：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>模体对象有一个 <tt class="docutils literal"><span class="pre">.counts</span></tt> 属性，可以用来查看碱基在每个位置的数目。可以把这个统计表用易读的格式打印出来：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">m</span><span class="o">.</span><span class="n">counts</span>
<span class="go">        0      1      2      3      4</span>
<span class="go">A:   3.00   7.00   0.00   2.00   1.00</span>
<span class="go">C:   0.00   0.00   5.00   2.00   6.00</span>
<span class="go">G:   0.00   0.00   0.00   3.00   0.00</span>
<span class="go">T:   4.00   0.00   2.00   0.00   0.00</span>
</pre></div>
</div>
<p>你也可以像使用字典一样获取这些数目：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span>
<span class="go">[3, 7, 0, 2, 1]</span>
</pre></div>
</div>
<p>但是你也可以把它看成一个二维数列，核苷酸作为列，位置作为行：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">0</span>
</pre></div>
</div>
<p>你还可以直接获得核苷酸数目矩阵中的列</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">{&#39;A&#39;: 2, &#39;C&#39;: 2, &#39;T&#39;: 0, &#39;G&#39;: 3}</span>
</pre></div>
</div>
<p>除了使用核苷酸本身，你还可以使用模体碱基序列按字符排序后的核苷酸索引：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span>
<span class="go">IUPACUnambiguousDNA()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">letters</span>
<span class="go">&#39;GATC&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">letters</span><span class="p">)</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">,:]</span>
<span class="go">(3, 7, 0, 2, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="go">(3, 7, 0, 2, 1)</span>
</pre></div>
</div>
<p>模体有一个相关联的一致序列，这个序列被定义为由 <tt class="docutils literal"><span class="pre">.counts</span></tt> 矩阵相应列中具有最大值的碱基，这些碱基是按模体序列排列的：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">Seq(&#39;TACGC&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>反一致序列也一样，只不过是由 <tt class="docutils literal"><span class="pre">.counts</span></tt> 矩阵中相应列的最小值来选：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">anticonsensus</span>
<span class="go">Seq(&#39;GGGTG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>你也可以利用简并一致序列，用不确定核苷酸来表示序列某一位置的所有核苷酸：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">degenerate_consensus</span>
<span class="go">Seq(&#39;WACVC&#39;, IUPACAmbiguousDNA())</span>
</pre></div>
</div>
<p>此处，W和R都是按照IUPAC不确定核苷酸表规定的：W代表A或T，V代表A，C或G [<a class="reference internal" href="chr23.html#cornish1985"><em>10</em></a>] 。这些简并一致序列是按照Cavener指定的规则 [<a class="reference internal" href="chr23.html#cavener1987"><em>11</em></a>] 来建立的。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">Seq(&#39;GCGTA&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">degenerate_consensus</span>
<span class="go">Seq(&#39;GBGTW&#39;, IUPACAmbiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r</span>
<span class="go">TTGTA</span>
<span class="go">GCGTA</span>
<span class="go">GTGTA</span>
<span class="go">GGGTA</span>
<span class="go">GGGTT</span>
<span class="go">GCATT</span>
<span class="go">GCATT</span>
</pre></div>
</div>
<p>反向互补序列和简并一致序列都只在DNA模体中有。</p>
</div>
<div class="section" id="id3">
<h3>14.1.2  读取模体<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>从实例手动创建一个模体确实有点无趣，所以用一些I/O函数来读写模体是很有用的。目前对于如何存储模体还没有一些真正的标准，不过有一些格式用得比其他更经常。这其中最重要的区别在于模体表示是基于实例还是某种PWM矩阵。</p>
<div class="section" id="jaspar">
<h4>JASPAR<a class="headerlink" href="#jaspar" title="Permalink to this headline">¶</a></h4>
<p>作为一个最流行的模体数据库 <a class="reference external" href="http://jaspar.genereg.net">JASPAR</a> 它不是以一系列的实例就是频率矩阵。比如，下面就是JASPAR <tt class="docutils literal"><span class="pre">Arnt.sites</span></tt> 文件的开头和结尾行显示了老鼠螺旋-环-螺旋转录因子Arnt的结合位点：</p>
<div class="code python highlight-python"><pre>&gt;MA0004 ARNT    1
CACGTGatgtcctc
&gt;MA0004 ARNT    2
CACGTGggaggtac
&gt;MA0004 ARNT    3
CACGTGccgcgcgc
...
&gt;MA0004 ARNT    18
AACGTGacagccctcc
&gt;MA0004 ARNT    19
AACGTGcacatcgtcc
&gt;MA0004 ARNT    20
aggaatCGCGTGc</pre>
</div>
<p>那些用大字字母表示的序列的一部分就是被用来相互比对的模体实例。</p>
<p>我们可以从下面的实例创建一个 <tt class="docutils literal"><span class="pre">Motif</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">motifs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arnt</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;Arnt.sites&quot;</span><span class="p">),</span> <span class="s">&quot;sites&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>从这个模体创建的实例存储在该模体的 <tt class="docutils literal"><span class="pre">.instances</span></tt> 属性：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">arnt</span><span class="o">.</span><span class="n">instances</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[Seq(&#39;CACGTG&#39;, IUPACUnambiguousDNA()), Seq(&#39;CACGTG&#39;, IUPACUnambiguousDNA()), Seq(&#39;CACGTG&#39;, IUPACUnambiguousDNA())]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">arnt</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">instance</span>
<span class="gp">...</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">CACGTG</span>
<span class="go">AACGTG</span>
<span class="go">AACGTG</span>
<span class="go">AACGTG</span>
<span class="go">AACGTG</span>
<span class="go">CGCGTG</span>
</pre></div>
</div>
<p>这个模体的计数矩阵可以从这些实例中自动计算出来：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">arnt</span><span class="o">.</span><span class="n">counts</span>
<span class="go">        0      1      2      3      4      5</span>
<span class="go">A:   4.00  19.00   0.00   0.00   0.00   0.00</span>
<span class="go">C:  16.00   0.00  20.00   0.00   0.00   0.00</span>
<span class="go">G:   0.00   1.00   0.00  20.00   0.00  20.00</span>
<span class="go">T:   0.00   0.00   0.00   0.00  20.00   0.00</span>
</pre></div>
</div>
<p>JASPAR数据库也可以让模体像计数矩阵一样获得，不需要那些创建它们的实例。比如，下面这个JASPAR文件 <tt class="docutils literal"><span class="pre">SRF.pfm</span></tt> 包含了人类SRF转录因子的计数矩阵：</p>
<div class="code python highlight-python"><pre> 2  9  0  1 32  3 46  1 43 15  2  2
 1 33 45 45  1  1  0  0  0  1  0  1
39  2  1  0  0  0  0  0  0  0 44 43
 4  2  0  0 13 42  0 45  3 30  0  0</pre>
</div>
<p>我们可以如下为计数矩阵创建一个模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">srf</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;SRF.pfm&quot;</span><span class="p">),</span><span class="s">&quot;pfm&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">srf</span><span class="o">.</span><span class="n">counts</span>
<span class="go">        0      1      2      3      4      5      6      7      8      9     10     11</span>
<span class="go">A:   2.00   9.00   0.00   1.00  32.00   3.00  46.00   1.00  43.00  15.00   2.00   2.00</span>
<span class="go">C:   1.00  33.00  45.00  45.00   1.00   1.00   0.00   0.00   0.00   1.00   0.00   1.00</span>
<span class="go">G:  39.00   2.00   1.00   0.00   0.00   0.00   0.00   0.00   0.00   0.00  44.00  43.00</span>
<span class="go">T:   4.00   2.00   0.00   0.00  13.00  42.00   0.00  45.00   3.00  30.00   0.00   0.00</span>
</pre></div>
</div>
<p>由于这个模体是由计数矩阵直接创建的，所以它没有相关的实例：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">srf</span><span class="o">.</span><span class="n">instances</span>
<span class="go">None</span>
</pre></div>
</div>
<p>我们可以获得这两个模体的一致序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">arnt</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">CACGTG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">srf</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">GCCCATATATGG</span>
</pre></div>
</div>
</div>
<div class="section" id="meme">
<h4>MEME<a class="headerlink" href="#meme" title="Permalink to this headline">¶</a></h4>
<p>MEME [<a class="reference internal" href="chr23.html#bailey1994"><em>12</em></a>] 是一个用来在一堆相关DNA或蛋白质序列中发现模体的工具。它输入一组相关DNA或蛋白质序列，输出所要求的模体。因此和JASPAR文件相比，MEME输出文件里面一般是含有多个模体。例子如下。</p>
<p>在输出文件的开头，有一些MEME生成的关于MEME和所用MEME版本的背景信息：</p>
<div class="code python highlight-python"><pre>********************************************************************************
MEME - Motif discovery tool
********************************************************************************
MEME version 3.0 (Release date: 2004/08/18 09:07:01)
...</pre>
</div>
<p>再往下，简要概括了输入的训练序列集：</p>
<div class="code python highlight-python"><pre>********************************************************************************
TRAINING SET
********************************************************************************
DATAFILE= INO_up800.s
ALPHABET= ACGT
Sequence name            Weight Length  Sequence name            Weight Length
-------------            ------ ------  -------------            ------ ------
CHO1                     1.0000    800  CHO2                     1.0000    800
FAS1                     1.0000    800  FAS2                     1.0000    800
ACC1                     1.0000    800  INO1                     1.0000    800
OPI3                     1.0000    800
********************************************************************************</pre>
</div>
<p>以及所使用到的命令：</p>
<div class="code python highlight-python"><pre>********************************************************************************
COMMAND LINE SUMMARY
********************************************************************************
This information can also be useful in the event you wish to report a
problem with the MEME software.

command: meme -mod oops -dna -revcomp -nmotifs 2 -bfile yeast.nc.6.freq INO_up800.s
...</pre>
</div>
<p>接下来就是每个被发现模体的详细信息：</p>
<div class="code python highlight-python"><pre>********************************************************************************
MOTIF  1        width =   12   sites =   7   llr = 95   E-value = 2.0e-001
********************************************************************************
--------------------------------------------------------------------------------
        Motif 1 Description
--------------------------------------------------------------------------------
Simplified        A  :::9:a::::3:
pos.-specific     C  ::a:9:11691a
probability       G  ::::1::94:4:
matrix            T  aa:1::9::11:</pre>
</div>
<p>使用下面的方法来读取这个文件（以 <tt class="docutils literal"><span class="pre">meme.dna.oops.txt</span></tt> 存储）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;meme.dna.oops.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">&quot;meme&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">motifs.parse</span></tt> 命令直接读取整个文件，所以在使用后可以关闭这个文件。其中头文件信息被存储于属性中</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">version</span>
<span class="go">&#39;3.0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">datafile</span>
<span class="go">&#39;INO_up800.s&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">command</span>
<span class="go">&#39;meme -mod oops -dna -revcomp -nmotifs 2 -bfile yeast.nc.6.freq INO_up800.s&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">alphabet</span>
<span class="go">IUPACUnambiguousDNA()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">sequences</span>
<span class="go">[&#39;CHO1&#39;, &#39;CHO2&#39;, &#39;FAS1&#39;, &#39;FAS2&#39;, &#39;ACC1&#39;, &#39;INO1&#39;, &#39;OPI3&#39;]</span>
</pre></div>
</div>
<p>这个数据记录是 <tt class="docutils literal"><span class="pre">Bio.motifs.meme.Record</span></tt> 类的一个对象。这个类继承于列表（list），所以你可以把这个 <tt class="docutils literal"><span class="pre">record</span></tt> 看成模体对象的一个列表：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motif</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">TTCACATGCCGC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motif</span><span class="o">.</span><span class="n">degenerate_consensus</span>
<span class="go">TTCACATGSCNC</span>
</pre></div>
</div>
<p>除了一般的模体属性外，每个模体还同时保存着它们由MEME计算的各自特异信息。例如：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">num_occurrences</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">length</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evalue</span> <span class="o">=</span> <span class="n">motif</span><span class="o">.</span><span class="n">evalue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%3.1g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">evalue</span>
<span class="go">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;Motif 1&#39;</span>
</pre></div>
</div>
<p>除了像上面所做的用索引来获得相关记录，你也可以用它的名称来找到这个记录：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="s">&#39;Motif 1&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>每个模体都有一个 <tt class="docutils literal"><span class="pre">.instances</span></tt> 属性与在这个被发现模体中的序列实例，能够为每个实例提供一些信息：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">motif</span><span class="o">.</span><span class="n">instances</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">Instance(&#39;TTCACATGCCGC&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">motif_name</span>
<span class="go">&#39;Motif 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sequence_name</span>
<span class="go">&#39;INO1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
<span class="go">620</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strand</span>
<span class="go">&#39;-&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">length</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pvalue</span> <span class="o">=</span> <span class="n">motif</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pvalue</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%5.3g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">pvalue</span>
<span class="go">1.85e-08</span>
</pre></div>
</div>
</div>
<div class="section" id="mast">
<h4>MAST<a class="headerlink" href="#mast" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="transfac">
<h4>TRANSFAC<a class="headerlink" href="#transfac" title="Permalink to this headline">¶</a></h4>
<p>TRANSFAC是一个为转录因子手动创建的一个专业数据库，同时还包括染色体结合位点和DNA结合的描述 [<a class="reference internal" href="chr23.html#matys2003"><em>27</em></a>] 。TRANSFAC数据库中所用的文件格式至今还被其他工具所使用，我们下面将介绍TRANSFAC文件格式。</p>
<p>TRANSFAC文件格式简单概括如下：</p>
<div class="code python highlight-python"><pre>ID  motif1
P0      A      C      G      T
01      1      2      2      0      S
02      2      1      2      0      R
03      3      0      1      1      A
04      0      5      0      0      C
05      5      0      0      0      A
06      0      0      4      1      G
07      0      1      4      0      G
08      0      0      0      5      T
09      0      0      5      0      G
10      0      1      2      2      K
11      0      2      0      3      Y
12      1      0      3      1      G
//</pre>
</div>
<p>这个文件显示了模体 <tt class="docutils literal"><span class="pre">motif1</span></tt> 中12个核苷酸的频率矩阵。总的来说，一个TRANSFAC文件里面可以包含多个模体。以下是示例文件 <tt class="docutils literal"><span class="pre">transfac.dat</span></tt> 的内容：</p>
<div class="code python highlight-python"><pre>VV  EXAMPLE January 15, 2013
XX
//
ID  motif1
P0      A      C      G      T
01      1      2      2      0      S
02      2      1      2      0      R
03      3      0      1      1      A
...
11      0      2      0      3      Y
12      1      0      3      1      G
//
ID  motif2
P0      A      C      G      T
01      2      1      2      0      R
02      1      2      2      0      S
...
09      0      0      0      5      T
10      0      2      0      3      Y
//</pre>
</div>
<p>可用如下方法读取TRANSFAC文件：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;transfac.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">&quot;TRANSFAC&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>如果有总版本号的话，它是存储在 <tt class="docutils literal"><span class="pre">record.version</span></tt> 中：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">version</span>
<span class="go">&#39;EXAMPLE January 15, 2013&#39;</span>
</pre></div>
</div>
<p>每个在 <tt class="docutils literal"><span class="pre">record</span></tt> 中的模体都是 <tt class="docutils literal"><span class="pre">Bio.motifs.transfac.Motif</span></tt> 类的实例，这些实例同时继承 <tt class="docutils literal"><span class="pre">Bio.motifs.Motif</span></tt> 类和Python字典的属性。这些字典用双字母的键来存储关于这个模体的其他附加信息：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">degenerate_consensus</span> <span class="c"># Using the Bio.motifs.Motif method</span>
<span class="go">Seq(&#39;SRACAGGTGKYG&#39;, IUPACAmbiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="p">[</span><span class="s">&#39;ID&#39;</span><span class="p">]</span> <span class="c"># Using motif as a dictionary</span>
<span class="go">&#39;motif1&#39;</span>
</pre></div>
</div>
<p>TRANSFAC文件一般比这些例子更详细，包含了许多关于模体的附加信息。表格 <a class="reference internal" href="#table-transfaccodes"><em>14.1.2</em></a> 列出了在TRANSFAC文件常见的双字母含义：</p>
<hr class="docutils" />
<table border="1" class="docutils" id="table-transfaccodes">
<colgroup>
<col width="100%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Table 14.1: TRANSFAC文件中常见的字段</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">AC</span></tt></td>
<td>Accession numbers 序列号</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">AS</span></tt></td>
<td>Accession numbers, secondary 第二序列号</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">BA</span></tt></td>
<td>Statistical basis 统计依据</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">BF</span></tt></td>
<td>Binding factors 结合因子</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">BS</span></tt></td>
<td>Factor binding sites underlying the matrix
基于矩阵的转录结合位点</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">CC</span></tt></td>
<td>Comments 注解</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">CO</span></tt></td>
<td>Copyright notice 版权事项</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">DE</span></tt></td>
<td>Short factor description 短因子说明</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">DR</span></tt></td>
<td>External databases 外部数据库</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">DT</span></tt></td>
<td>Date created/updated 创建或更新日期</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">HC</span></tt></td>
<td>Subfamilies 亚家庭名称</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">HP</span></tt></td>
<td>Superfamilies 超家庭名称</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">ID</span></tt></td>
<td>Identifier 身份证</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">NA</span></tt></td>
<td>Name of the binding factor 结合因子的名称</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">OC</span></tt></td>
<td>Taxonomic classification 分类</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">OS</span></tt></td>
<td>Species/Taxon 种类或分类</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">OV</span></tt></td>
<td>Older version 旧版本</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">PV</span></tt></td>
<td>Preferred version 首选版本</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">TY</span></tt></td>
<td>Type 类型</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">XX</span></tt></td>
<td>Empty line; these are not stored in the Record.
空白行;没在记录中存储的数据</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>每个模体同时也有一个包含与这个模体相关参考资料的 <tt class="docutils literal"><span class="pre">references</span></tt> 属性，用下面的双字母键来获得：</p>
<hr class="docutils" />
<table border="1" class="docutils">
<colgroup>
<col width="100%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Table 14.2: TRANSFAC文件中用来存储参考资料的字段</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">RN</span></tt></td>
<td>Reference number 参考数目</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">RA</span></tt></td>
<td>Reference authors 参考资料作者</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">RL</span></tt></td>
<td>Reference data 参考数据</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">RT</span></tt></td>
<td>Reference title 参考标题</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">RX</span></tt></td>
<td>PubMed ID</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>将TRANSFAC文件按原来格式打印出来：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">record</span>
<span class="go">VV  EXAMPLE January 15, 2013</span>
<span class="go">XX</span>
<span class="go">//</span>
<span class="go">ID  motif1</span>
<span class="go">XX</span>
<span class="go">P0      A      C      G      T</span>
<span class="go">01      1      2      2      0      S</span>
<span class="go">02      2      1      2      0      R</span>
<span class="go">03      3      0      1      1      A</span>
<span class="go">04      0      5      0      0      C</span>
<span class="go">05      5      0      0      0      A</span>
<span class="go">06      0      0      4      1      G</span>
<span class="go">07      0      1      4      0      G</span>
<span class="go">08      0      0      0      5      T</span>
<span class="go">09      0      0      5      0      G</span>
<span class="go">10      0      1      2      2      K</span>
<span class="go">11      0      2      0      3      Y</span>
<span class="go">12      1      0      3      1      G</span>
<span class="go">XX</span>
<span class="go">//</span>
<span class="go">ID  motif2</span>
<span class="go">XX</span>
<span class="go">P0      A      C      G      T</span>
<span class="go">01      2      1      2      0      R</span>
<span class="go">02      1      2      2      0      S</span>
<span class="go">03      0      5      0      0      C</span>
<span class="go">04      3      0      1      1      A</span>
<span class="go">05      0      0      4      1      G</span>
<span class="go">06      5      0      0      0      A</span>
<span class="go">07      0      1      4      0      G</span>
<span class="go">08      0      0      5      0      G</span>
<span class="go">09      0      0      0      5      T</span>
<span class="go">10      0      2      0      3      Y</span>
<span class="go">XX</span>
<span class="go">//</span>
</pre></div>
</div>
<p>通过用字符串形式来截取输出并且保存在文件中，你可以按TRANSFAC的格式导出这些模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;mytransfacfile.dat&quot;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h3>14.1.3  模体写出<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>说到导出，我们可以先看看导出函数。以JASPAR <tt class="docutils literal"><span class="pre">.pfm</span></tt> 格式导出模体文件，可以用：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">m</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;pfm&quot;</span><span class="p">)</span>
<span class="go">3       7       0       2       1</span>
<span class="go">0       0       5       2       6</span>
<span class="go">0       0       0       3       0</span>
<span class="go">4       0       2       0       0</span>
</pre></div>
</div>
<p>用类似TRANSFAC的格式导出一个模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">m</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;transfac&quot;</span><span class="p">)</span>
<span class="go">P0      A      C      G      T</span>
<span class="go">01      3      0      0      4      W</span>
<span class="go">02      7      0      0      0      A</span>
<span class="go">03      0      5      0      2      C</span>
<span class="go">04      2      2      3      0      V</span>
<span class="go">05      1      6      0      0      C</span>
<span class="go">XX</span>
<span class="go">//</span>
</pre></div>
</div>
<p>你可以用 <tt class="docutils literal"><span class="pre">motifs.write</span></tt> 来写出多个模体。这个函数在使用的时候不必担心这些模体来自于TRANSFAC文件。比如：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">two_motifs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arnt</span><span class="p">,</span> <span class="n">srf</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motifs</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">two_motifs</span><span class="p">,</span> <span class="s">&#39;transfac&#39;</span><span class="p">)</span>
<span class="go">P0      A      C      G      T</span>
<span class="go">01      4     16      0      0      C</span>
<span class="go">02     19      0      1      0      A</span>
<span class="go">03      0     20      0      0      C</span>
<span class="go">04      0      0     20      0      G</span>
<span class="go">05      0      0      0     20      T</span>
<span class="go">06      0      0     20      0      G</span>
<span class="go">XX</span>
<span class="go">//</span>
<span class="go">P0      A      C      G      T</span>
<span class="go">01      2      1     39      4      G</span>
<span class="go">02      9     33      2      2      C</span>
<span class="go">03      0     45      1      0      C</span>
<span class="go">04      1     45      0      0      C</span>
<span class="go">05     32      1      0     13      A</span>
<span class="go">06      3      1      0     42      T</span>
<span class="go">07     46      0      0      0      A</span>
<span class="go">08      1      0      0     45      T</span>
<span class="go">09     43      0      0      3      A</span>
<span class="go">10     15      1      0     30      T</span>
<span class="go">11      2      0     44      0      G</span>
<span class="go">12      2      1     43      0      G</span>
<span class="go">XX</span>
<span class="go">//</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>14.1.4  绘制序列标识图<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>如果能够联网，我们可以创建一个 <a class="reference external" href="http://weblogo.berkeley.edu">weblogo</a> ：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arnt</span><span class="o">.</span><span class="n">weblogo</span><span class="p">(</span><span class="s">&quot;Arnt.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>将得到的标识图存储成PNG格式。</p>
</div>
</div>
<div class="section" id="id6">
<h2>14.2  位置权重矩阵<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>模体对象的 <tt class="docutils literal"><span class="pre">.counts</span></tt> 属性能够显示在序列上每个位置核苷酸出现的次数。我们可以把这矩阵除以序列中的实例数目来标准化这矩阵，得到每个核苷酸在序列位置上出现概率。我们把这概率看作位置权重矩阵。不过，要知道在字面上，这个术语也可以用来说明位置特异性得分矩阵，这个我们将会在下面讨论。</p>
<p>通常来说，伪计数（pseudocounts）在归一化之前都已经加到每个位置中。这样可以避免在这序列上过度拟合位置权重矩阵以至趋向于模体的实例的有限数量，还可以避免概率为0。向每个位置的核苷酸添加一个固定的伪计数，可以为 <tt class="docutils literal"><span class="pre">pseudocounts</span></tt> 参数指定一个数值：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">pseudocounts</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pwm</span>
<span class="go">        0      1      2      3      4</span>
<span class="go">A:   0.39   0.83   0.06   0.28   0.17</span>
<span class="go">C:   0.06   0.06   0.61   0.28   0.72</span>
<span class="go">G:   0.06   0.06   0.06   0.39   0.06</span>
<span class="go">T:   0.50   0.06   0.28   0.06   0.06</span>
</pre></div>
</div>
<p>另外， <tt class="docutils literal"><span class="pre">pseudocounts</span></tt> 可以利用字典为每个核苷酸指定一个伪计数值。例如，由于在人类基因组中GC含量大概为40%,因此可以选择下面这些伪计数值：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">pseudocounts</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span><span class="mf">0.6</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pwm</span>
<span class="go">        0      1      2      3      4</span>
<span class="go">A:   0.40   0.84   0.07   0.29   0.18</span>
<span class="go">C:   0.04   0.04   0.60   0.27   0.71</span>
<span class="go">G:   0.04   0.04   0.04   0.38   0.04</span>
<span class="go">T:   0.51   0.07   0.29   0.07   0.07</span>
</pre></div>
</div>
<p>位置权重矩阵有它自己的方法计算一致序列、反向一致序列和简并一致序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">Seq(&#39;TACGC&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span><span class="o">.</span><span class="n">anticonsensus</span>
<span class="go">Seq(&#39;GGGTG&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm</span><span class="o">.</span><span class="n">degenerate_consensus</span>
<span class="go">Seq(&#39;WACNC&#39;, IUPACAmbiguousDNA())</span>
</pre></div>
</div>
<p>应当注意到由于伪计数的原因，由位置仅重矩阵计算得到的简并一致序列和由模体中实例计算得到的简并一致序列有一点不同：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">degenerate_consensus</span>
<span class="go">Seq(&#39;WACVC&#39;, IUPACAmbiguousDNA())</span>
</pre></div>
</div>
<p>位置权重矩阵的反向互补矩阵可以直接用 <tt class="docutils literal"><span class="pre">pwm</span></tt> 计算出来：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rpwm</span> <span class="o">=</span> <span class="n">pwm</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">rpwm</span>
<span class="go">        0      1      2      3      4</span>
<span class="go">A:   0.07   0.07   0.29   0.07   0.51</span>
<span class="go">C:   0.04   0.38   0.04   0.04   0.04</span>
<span class="go">G:   0.71   0.27   0.60   0.04   0.04</span>
<span class="go">T:   0.18   0.29   0.07   0.84   0.40</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>14.3  位置特异性得分矩阵<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>使用背景分布和加入伪计数的PWM，很容易就能计算出log-odds比率，提供特定标记的log odds值，这值来自于在这个背景的模体。我们可以用在位置仅重矩阵中 <tt class="docutils literal"><span class="pre">.log-odds()</span></tt> 方法：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pssm</span> <span class="o">=</span> <span class="n">pwm</span><span class="o">.</span><span class="n">log_odds</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pssm</span>
<span class="go">        0      1      2      3      4</span>
<span class="go">A:   0.68   1.76  -1.91   0.21  -0.49</span>
<span class="go">C:  -2.49  -2.49   1.26   0.09   1.51</span>
<span class="go">G:  -2.49  -2.49  -2.49   0.60  -2.49</span>
<span class="go">T:   1.03  -1.91   0.21  -1.91  -1.91</span>
</pre></div>
</div>
<p>这时我们可以更经常看到特定标记和背景下的正值和负值。0.0意味着在模体和背景中观察到一个标记有相等的可能性。</p>
<p>上面是假设A,C,G和T在背景中出现的概率是相同的。那在A,C,G和T出现概率不同的情况下，为了计算特定背景下的位置特异性得分矩阵，可以使用 <tt class="docutils literal"><span class="pre">background</span></tt> 参数。例如，在40%GC含量的背景下，可以用：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span><span class="mf">0.3</span><span class="p">,</span><span class="s">&#39;C&#39;</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span><span class="s">&#39;G&#39;</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span><span class="s">&#39;T&#39;</span><span class="p">:</span><span class="mf">0.3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pssm</span> <span class="o">=</span> <span class="n">pwm</span><span class="o">.</span><span class="n">log_odds</span><span class="p">(</span><span class="n">background</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pssm</span>
<span class="go">        0      1      2      3      4</span>
<span class="go">A:   0.42   1.49  -2.17  -0.05  -0.75</span>
<span class="go">C:  -2.17  -2.17   1.58   0.42   1.83</span>
<span class="go">G:  -2.17  -2.17  -2.17   0.92  -2.17</span>
<span class="go">T:   0.77  -2.17  -0.05  -2.17  -2.17</span>
</pre></div>
</div>
<p>从PSSM中得到的最大和最小值被存储在 <tt class="docutils literal"><span class="pre">.max</span></tt> 和 <tt class="docutils literal"><span class="pre">.min</span></tt> 属性中：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%4.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">pssm</span><span class="o">.</span><span class="n">max</span>
<span class="go">6.59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%4.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">pssm</span><span class="o">.</span><span class="n">min</span>
<span class="go">-10.85</span>
</pre></div>
</div>
<p>在特定背景下计算平均值和标准方差使用 <tt class="docutils literal"><span class="pre">.mean</span></tt> 和 <tt class="docutils literal"><span class="pre">.std</span></tt> 方法。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">pssm</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">background</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std</span> <span class="o">=</span> <span class="n">pssm</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">background</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;mean = </span><span class="si">%0.2f</span><span class="s">, standard deviation = </span><span class="si">%0.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>
<span class="go">mean = 3.21, standard deviation = 2.59</span>
</pre></div>
</div>
<p>如果没有指定特定的背景，就会使用一个统一的背景。因为同KL散度或相对熵的值相同，所以平均值就显得特别重要，并且它也是同背景相比的模体信息含量的测量方法。由于在Biopython中用以2为底的对数来计算log-odds值，信息含量的的单位是bit。</p>
<p><tt class="docutils literal"><span class="pre">.reverse_complement</span></tt>, <tt class="docutils literal"><span class="pre">.consensus</span></tt>, <tt class="docutils literal"><span class="pre">.anticonsensus</span></tt> 和 <tt class="docutils literal"><span class="pre">.degenerate_consensus</span></tt> 方法可以直接对PSSM使用。</p>
</div>
<div class="section" id="id8">
<h2>14.4  搜索实例<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>模体最常用的功能就是在序列中的查找它的实例。在这节，我们会用如下的序列作为例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">test_seq</span><span class="o">=</span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TACACTGCATTACAACCCAAGCATTA&quot;</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">test_seq</span><span class="p">)</span>
<span class="go">26</span>
</pre></div>
</div>
<div class="section" id="id9">
<h3>14.4.1  搜索准确匹配实例<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>查找实例最简单的方法就是查找模体实例的准确匹配：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">seq</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">test_seq</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">pos</span><span class="p">,</span> <span class="n">seq</span>
<span class="gp">...</span>
<span class="go">0 TACAC</span>
<span class="go">10 TACAA</span>
<span class="go">13 AACCC</span>
</pre></div>
</div>
<p>我们可获得反向互补序列（找到互补链的实例）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">seq</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">test_seq</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">pos</span><span class="p">,</span> <span class="n">seq</span>
<span class="gp">...</span>
<span class="go">6 GCATT</span>
<span class="go">20 GCATT</span>
</pre></div>
</div>
</div>
<div class="section" id="pssm">
<h3>14.4.2  用PSSM得分搜索匹配实例<a class="headerlink" href="#pssm" title="Permalink to this headline">¶</a></h3>
<p>在模体中很容易找出相应的位置,引起对模体的高log-odds值：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">pssm</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">test_seq</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;Position </span><span class="si">%d</span><span class="s">: score = </span><span class="si">%5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Position 0: score = 5.622</span>
<span class="go">Position -20: score = 4.601</span>
<span class="go">Position 10: score = 3.037</span>
<span class="go">Position 13: score = 5.738</span>
<span class="go">Position -6: score = 4.601</span>
</pre></div>
</div>
<p>负值的位置是指在测试序列的反向链中找到的模体的实例，而且得力于Python的索引。在 <tt class="docutils literal"><span class="pre">pos</span></tt> 的模体实例可以用 <tt class="docutils literal"><span class="pre">test_seq[pos:pos+len(m)]</span></tt> 来定位，不管 <tt class="docutils literal"><span class="pre">pos</span></tt> 值是正还是负。</p>
<p>你可能注意到阀值参数，在这里随意地设为3.0。这里是 <em>log</em><sub>2</sub> ，所以我们现在开始寻找那些在模体中出现概率为背景中出现概率8倍序列。默认的阀值是0.0,在此阀值下，会把所有比背景中出现概率大的模体实例都找出来。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pssm</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">test_seq</span><span class="p">)</span>
<span class="go">array([  5.62230396,  -5.6796999 ,  -3.43177247,   0.93827754,</span>
<span class="go">        -6.84962511,  -2.04066086, -10.84962463,  -3.65614533,</span>
<span class="go">        -0.03370807,  -3.91102552,   3.03734159,  -2.14918518,</span>
<span class="go">        -0.6016975 ,   5.7381525 ,  -0.50977498,  -3.56422281,</span>
<span class="go">        -8.73414803,  -0.09919716,  -0.6016975 ,  -2.39429784,</span>
<span class="go">       -10.84962463,  -3.65614533], dtype=float32)</span>
</pre></div>
</div>
<p>通常来说，上述是计算PSSM得分的最快方法。这些得分只能由前导链用 <tt class="docutils literal"><span class="pre">pssm.calculate</span></tt> 计算得到。为了得到互补链的PSSM值，你可以利用PSSM的互补矩阵：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rpssm</span> <span class="o">=</span> <span class="n">pssm</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rpssm</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">test_seq</span><span class="p">)</span>
<span class="go">array([ -9.43458748,  -3.06172252,  -7.18665981,  -7.76216221,</span>
<span class="go">        -2.04066086,  -4.26466274,   4.60124254,  -4.2480607 ,</span>
<span class="go">        -8.73414803,  -2.26503372,  -6.49598789,  -5.64668512,</span>
<span class="go">        -8.73414803, -10.84962463,  -4.82356262,  -4.82356262,</span>
<span class="go">        -5.64668512,  -8.73414803,  -4.15613794,  -5.6796999 ,</span>
<span class="go">         4.60124254,  -4.2480607 ], dtype=float32)</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>14.4.3  选择得分阀值<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>如果不想刚才那么随意设定一个阀值，你可以探究一下PSSM得分的分布。由于得分的空间分布随着模体长度而成倍增长，我们用一个近似于给定精度值来计算，如此可使计算成本更容易控制：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">distribution</span> <span class="o">=</span> <span class="n">pssm</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span><span class="n">background</span><span class="o">=</span><span class="n">background</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">distribution</span></tt> 对象可以用来决定许多不同的阀值。我们可以指定一个需要的的假阳性率（找到一个由序列在此背景下产生的模体实例的概率）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">threshold_fpr</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">threshold</span>
<span class="go">4.009</span>
</pre></div>
</div>
<p>或者假阴性率（找不到模体产生的实例概率）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">threshold_fnr</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">threshold</span>
<span class="go">-0.510</span>
</pre></div>
</div>
<p>或者一个阀值（近似），满足假阳性率和假阴性率之间的关系（fnr/fpr≃ <em>t</em>)：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">threshold_balanced</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">threshold</span>
<span class="go">6.241</span>
</pre></div>
</div>
<p>或者一个阀值能够大体满足假阳性率和信息含量的 −<em>log</em> 值之间的相等关系（与Hertz和Stormo的Patser软件所用的一样）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">threshold_patser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">threshold</span>
<span class="go">0.346</span>
</pre></div>
</div>
<p>比如在我们这个模体中，当以1000比率的平衡阀值查找实例，你可以得到一个让你获得相同结果的阀值（对这个序列来说）。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">threshold_fpr</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">threshold</span>
<span class="go">4.009</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">pssm</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">test_seq</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;Position </span><span class="si">%d</span><span class="s">: score = </span><span class="si">%5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Position 0: score = 5.622</span>
<span class="go">Position -20: score = 4.601</span>
<span class="go">Position 13: score = 5.738</span>
<span class="go">Position -6: score = 4.601</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id11">
<h2>14.5  模体对象自身相关的位置特异性得分矩阵<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>为了更好的利用PSSMs来查找潜在的TFBSs，每个模体都同位置权重矩阵和位置特异性得分矩阵相关联。用Arnt模体来举个例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">motifs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;Arnt.sites&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">&#39;sites&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motif</span><span class="o">.</span><span class="n">counts</span>
<span class="go">        0      1      2      3      4      5</span>
<span class="go">A:   4.00  19.00   0.00   0.00   0.00   0.00</span>
<span class="go">C:  16.00   0.00  20.00   0.00   0.00   0.00</span>
<span class="go">G:   0.00   1.00   0.00  20.00   0.00  20.00</span>
<span class="go">T:   0.00   0.00   0.00   0.00  20.00   0.00</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motif</span><span class="o">.</span><span class="n">pwm</span>
<span class="go">        0      1      2      3      4      5</span>
<span class="go">A:   0.20   0.95   0.00   0.00   0.00   0.00</span>
<span class="go">C:   0.80   0.00   1.00   0.00   0.00   0.00</span>
<span class="go">G:   0.00   0.05   0.00   1.00   0.00   1.00</span>
<span class="go">T:   0.00   0.00   0.00   0.00   1.00   0.00</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motif</span><span class="o">.</span><span class="n">pssm</span>
<span class="go">        0      1      2      3      4      5</span>
<span class="go">A:  -0.32   1.93   -inf   -inf   -inf   -inf</span>
<span class="go">C:   1.68   -inf   2.00   -inf   -inf   -inf</span>
<span class="go">G:   -inf  -2.32   -inf   2.00   -inf   2.00</span>
<span class="go">T:   -inf   -inf   -inf   -inf   2.00   -inf</span>
</pre></div>
</div>
<p>在这出现的负无穷大是由于在频率矩阵中相关项的值为0,并且我们默认使用0作为伪计数：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="s">&quot;ACGT&quot;</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%4.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">motif</span><span class="o">.</span><span class="n">pseudocounts</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">A: 0.00</span>
<span class="go">C: 0.00</span>
<span class="go">G: 0.00</span>
<span class="go">T: 0.00</span>
</pre></div>
</div>
<p>如果你更改了 <tt class="docutils literal"><span class="pre">.pseudocouts</span></tt> 属性，那么位置频率矩阵和位置特异性得分矩阵就都会自动重新计算：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">pseudocounts</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="s">&quot;ACGT&quot;</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%4.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">motif</span><span class="o">.</span><span class="n">pseudocounts</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">A: 3.00</span>
<span class="go">C: 3.00</span>
<span class="go">G: 3.00</span>
<span class="go">T: 3.00</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motif</span><span class="o">.</span><span class="n">pwm</span>
<span class="go">        0      1      2      3      4      5</span>
<span class="go">A:   0.22   0.69   0.09   0.09   0.09   0.09</span>
<span class="go">C:   0.59   0.09   0.72   0.09   0.09   0.09</span>
<span class="go">G:   0.09   0.12   0.09   0.72   0.09   0.72</span>
<span class="go">T:   0.09   0.09   0.09   0.09   0.72   0.09</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motif</span><span class="o">.</span><span class="n">pssm</span>
<span class="go">        0      1      2      3      4      5</span>
<span class="go">A:  -0.19   1.46  -1.42  -1.42  -1.42  -1.42</span>
<span class="go">C:   1.25  -1.42   1.52  -1.42  -1.42  -1.42</span>
<span class="go">G:  -1.42  -1.00  -1.42   1.52  -1.42   1.52</span>
<span class="go">T:  -1.42  -1.42  -1.42  -1.42   1.52  -1.42</span>
</pre></div>
</div>
<p>如果你想对4个核苷酸使用不同的伪计数，可以使用字典来设定4个核苷酸的 <tt class="docutils literal"><span class="pre">pseudocounts</span></tt> 。把 <tt class="docutils literal"><span class="pre">motif.pseudocounts</span></tt> 设为 <tt class="docutils literal"><span class="pre">None</span></tt> 会让伪计数重置为0的默认值。</p>
<p>位置特异性得分矩阵依赖于一个默认均一的背景分布：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="s">&quot;ACGT&quot;</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%4.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">motif</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">A: 0.25</span>
<span class="go">C: 0.25</span>
<span class="go">G: 0.25</span>
<span class="go">T: 0.25</span>
</pre></div>
</div>
<p>同样，如果你更改了背景分布，位置特异性得分矩阵也会重新计算：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">motif</span><span class="o">.</span><span class="n">pssm</span>
<span class="go">        0      1      2      3      4      5</span>
<span class="go">A:   0.13   1.78  -1.09  -1.09  -1.09  -1.09</span>
<span class="go">C:   0.98  -1.68   1.26  -1.68  -1.68  -1.68</span>
<span class="go">G:  -1.68  -1.26  -1.68   1.26  -1.68   1.26</span>
<span class="go">T:  -1.09  -1.09  -1.09  -1.09   1.85  -1.09</span>
</pre></div>
</div>
<p>把 <tt class="docutils literal"><span class="pre">motif.backgroud</span></tt> 设为 <tt class="docutils literal"><span class="pre">None</span></tt> 后会将其重置为均一的分布。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="s">&quot;ACGT&quot;</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%4.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">motif</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">A: 0.25</span>
<span class="go">C: 0.25</span>
<span class="go">G: 0.25</span>
<span class="go">T: 0.25</span>
</pre></div>
</div>
<p>如果你把 <tt class="docutils literal"><span class="pre">motif.background</span></tt> 设为一个单一值，这个值将会被看成是GC含量：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motif</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="s">&quot;ACGT&quot;</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%4.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">motif</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">A: 0.10</span>
<span class="go">C: 0.40</span>
<span class="go">G: 0.40</span>
<span class="go">T: 0.10</span>
</pre></div>
</div>
<p>应当注意到你能够在当前计算背景下计算PSSM的平均值：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">motif</span><span class="o">.</span><span class="n">pssm</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">motif</span><span class="o">.</span><span class="n">background</span><span class="p">)</span>
<span class="go">4.703928</span>
</pre></div>
</div>
<p>它的标准方差也是一样：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">motif</span><span class="o">.</span><span class="n">pssm</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">motif</span><span class="o">.</span><span class="n">background</span><span class="p">)</span>
<span class="go">3.290900</span>
</pre></div>
</div>
<p>和它的分布：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">distribution</span> <span class="o">=</span> <span class="n">motif</span><span class="o">.</span><span class="n">pssm</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span><span class="n">background</span><span class="o">=</span><span class="n">motif</span><span class="o">.</span><span class="n">background</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">threshold_fpr</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">threshold</span>
<span class="go">3.854375</span>
</pre></div>
</div>
<p>请注意，每当你调用 <tt class="docutils literal"><span class="pre">motif.pwm</span></tt> 或 <tt class="docutils literal"><span class="pre">motif.pssm</span></tt> ，位置仅重矩阵和位置特异性得分矩阵都会重新计算。如果看重速度并且需要重复用到PWM或PSSM时，你可以把他们保存成变量，如下所示：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pssm</span> <span class="o">=</span> <span class="n">motif</span><span class="o">.</span><span class="n">pssm</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>14.6  模体比较<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>当有多个模体时，我们就会想去比较它们。</p>
<p>在我们开始比较之前，应当要指出模体的边界通常比较模糊。这也就是说我们需要比较不同长度的模体，因此这些比较也要涉及到相关的比对。所以我们需要考虑两个东西：</p>
<ul class="simple">
<li>模体比对</li>
<li>比较比对后模体的相关函数</li>
</ul>
<p>为了比对模体，我们使用PSSMs的不含间隔的比对，并且用0来代替矩阵开始和结束位置缺失的列。这说明我们能够有效地利用背景分布来代替PSSM中缺失的列。距离函数然后可以返回模体间最小的距离，以及比对中相应的偏移量。</p>
<p>举个例子，先导入和测试模体 <tt class="docutils literal"><span class="pre">m</span></tt> 相似的模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m_reb1</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;REB1.pfm&quot;</span><span class="p">),</span> <span class="s">&quot;pfm&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m_reb1</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">Seq(&#39;GTTACCCGG&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">m_reb1</span><span class="o">.</span><span class="n">counts</span>
<span class="go">        0      1      2      3      4      5      6      7      8</span>
<span class="go">A:  30.00   0.00   0.00 100.00   0.00   0.00   0.00   0.00  15.00</span>
<span class="go">C:  10.00   0.00   0.00   0.00 100.00 100.00 100.00   0.00  15.00</span>
<span class="go">G:  50.00   0.00   0.00   0.00   0.00   0.00   0.00  60.00  55.00</span>
<span class="go">T:  10.00 100.00 100.00   0.00   0.00   0.00   0.00  40.00  15.00</span>
</pre></div>
</div>
<p>为了让模体能够进行相互比较，选择和模体 <tt class="docutils literal"><span class="pre">m</span></tt> 相同伪计数和背景值：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m_reb1</span><span class="o">.</span><span class="n">pseudocounts</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span><span class="mf">0.6</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m_reb1</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span><span class="mf">0.3</span><span class="p">,</span><span class="s">&#39;C&#39;</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span><span class="s">&#39;G&#39;</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span><span class="s">&#39;T&#39;</span><span class="p">:</span><span class="mf">0.3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pssm_reb1</span> <span class="o">=</span> <span class="n">m_reb1</span><span class="o">.</span><span class="n">pssm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pssm_reb1</span>
<span class="go">        0      1      2      3      4      5      6      7      8</span>
<span class="go">A:   0.00  -5.67  -5.67   1.72  -5.67  -5.67  -5.67  -5.67  -0.97</span>
<span class="go">C:  -0.97  -5.67  -5.67  -5.67   2.30   2.30   2.30  -5.67  -0.41</span>
<span class="go">G:   1.30  -5.67  -5.67  -5.67  -5.67  -5.67  -5.67   1.57   1.44</span>
<span class="go">T:  -1.53   1.72   1.72  -5.67  -5.67  -5.67  -5.67   0.41  -0.97</span>
</pre></div>
</div>
<p>我们将用皮尔逊相关（Pearson correlation）来比较这些模体。由于我们想要让它偏向于一个距离长度，我们实际上取1−<em>r</em> ，其中 <em>r</em> 是皮尔逊相关系数（Pearson correlation coefficient，PCC）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pssm</span><span class="o">.</span><span class="n">dist_pearson</span><span class="p">(</span><span class="n">pssm_reb1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;distance = </span><span class="si">%5.3g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">distance</span>
<span class="go">distance = 0.239</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">offset</span>
<span class="go">-2</span>
</pre></div>
</div>
<p>这意味着模体 <tt class="docutils literal"><span class="pre">m</span></tt> 和 <tt class="docutils literal"><span class="pre">m_reb1</span></tt> 间最佳PCC可以从下面的比对中获得：</p>
<div class="code python highlight-python"><pre>m:      bbTACGCbb
m_reb1: GTTACCCGG</pre>
</div>
<p>其中 <tt class="docutils literal"><span class="pre">b</span></tt> 代表背景分布。PCC值大概为1−0.239=0.761。</p>
</div>
<div class="section" id="de-novo">
<h2>14.7  查找 <em>De novo</em> 模体<a class="headerlink" href="#de-novo" title="Permalink to this headline">¶</a></h2>
<p>如今，Biopython对 <em>De novo</em> 模体查找的支持是有限的。也就是说，我们支持AlignAce和MEME的运行和读取。由于模体查找工具如雨后春笋般出现，所以很欢迎新的分析程序加入进来。</p>
<div class="section" id="id13">
<h3>14.7.1  MEME<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>假设用MEME以你喜欢的参数设置来跑序列，并把结果保存在文件 <tt class="docutils literal"><span class="pre">meme.out</span></tt> 中。你可以用以下的命令来得到MEME输出的模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">motifs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;meme.out&quot;</span><span class="p">),</span> <span class="s">&quot;meme&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span>
<span class="go">[&lt;Bio.motifs.meme.Motif object at 0xc356b0&gt;]</span>
</pre></div>
</div>
<p>除了最想要的一系列模体外，结果中还包含了很多有用的信息，可以通过那些一目了然的属性名获得：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">.alphabet</span></tt></li>
<li><tt class="docutils literal"><span class="pre">.datafile</span></tt></li>
<li><tt class="docutils literal"><span class="pre">.sequence_names</span></tt></li>
<li><tt class="docutils literal"><span class="pre">.version</span></tt></li>
<li><tt class="docutils literal"><span class="pre">.command</span></tt></li>
</ul>
<p>由MEME解析得到的模体可以像平常的模体对象（有实例）一样处理，它们也提供了一些额外的功能，可以为实例增加额外的信息。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">Seq(&#39;CTCAATCGTA&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sequence_name</span>
<span class="go">&#39;SEQ10;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strand</span>
<span class="go">&#39;+&#39;</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pvalue</span>
<span class="go">8.71e-07</span>
</pre></div>
</div>
</div>
<div class="section" id="alignace">
<h3>14.7.2  AlignAce<a class="headerlink" href="#alignace" title="Permalink to this headline">¶</a></h3>
<p>我们可以用AlignACE程序实现类似的效果。假如，你把结果保存在 <tt class="docutils literal"><span class="pre">alignace.out</span></tt> 文件中。你可以用下面的代码读取结果：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">motifs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsA</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;alignace.out&quot;</span><span class="p">),</span><span class="s">&quot;alignace&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>同样，你的模体也和正常的模体对象有相同的属性：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">Seq(&#39;TCTACGATTGAG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>事实上，你甚至可以观察到，AlignAce找到了一个和MEME非常相似的模体。下面只是MEME模体互补链的一个较长版本：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span><span class="o">.</span><span class="n">consensus</span>
<span class="go">Seq(&#39;TACGATTGAG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>如果你的机器上安装了AlignAce，你可以直接从Biopython中运行AlignAce。下面就是一个如何运行AlignAce的简单例子（其他参数可以用关键字参数来调用）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">command</span><span class="o">=</span><span class="s">&quot;/opt/bin/AlignACE&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">input_file</span><span class="o">=</span><span class="s">&quot;test.fa&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.motifs.applications</span> <span class="kn">import</span> <span class="n">AlignAceCommandline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmd</span> <span class="o">=</span> <span class="n">AlignAceCommandline</span><span class="p">(</span><span class="n">cmd</span><span class="o">=</span><span class="n">command</span><span class="p">,</span><span class="nb">input</span><span class="o">=</span><span class="n">input_file</span><span class="p">,</span><span class="n">gcback</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span><span class="n">numcols</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stdout</span><span class="p">,</span><span class="n">stderr</span><span class="o">=</span> <span class="n">cmd</span><span class="p">()</span>
</pre></div>
</div>
<p>由于AlignAce把所有的结果输出到标准输出，所以你可以通过读取结果的第一部分来获得模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifs</span> <span class="o">=</span> <span class="n">motifs</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span><span class="s">&quot;alignace&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sec-links">
<span id="id14"></span><h2>14.8  相关链接<a class="headerlink" href="#sec-links" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Sequence_motif">Sequence motif</a> in
wikipedia</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Position_weight_matrix">PWM</a> in
wikipedia</li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Consensus_sequence">Consensus
sequence</a> in
wikipedia</li>
<li><a class="reference external" href="http://bio.cs.washington.edu/assessment/">Comparison of different motif finding
programs</a></li>
</ul>
</div>
<div class="section" id="bio-motif">
<h2>14.9  旧版Bio.Motif模块<a class="headerlink" href="#bio-motif" title="Permalink to this headline">¶</a></h2>
<p>本章剩下部分将介绍Biopython 1.61版本前的 <tt class="docutils literal"><span class="pre">Bio.Motifs</span></tt> 模块，该模块取代了Biopython 1.50版本中基于两个早期Biopython模块—— <tt class="docutils literal"><span class="pre">Bio.AlignAce</span></tt> 和 <tt class="docutils literal"><span class="pre">Bio.MEME</span></tt> 的 <tt class="docutils literal"><span class="pre">Bio.Motif</span></tt> 模块。</p>
<p>为了平滑的过渡，早期的 <tt class="docutils literal"><span class="pre">Bio.Motif</span></tt> 模块将会和它的取代者 <tt class="docutils literal"><span class="pre">Bio.Motifs</span></tt> 一同维护到至少发行两个版本，并且持续至少一年。</p>
<div class="section" id="id15">
<h3>14.9.1  模体对象<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>由于我们对模体分析感兴趣，不过让我们首先看看 <tt class="docutils literal"><span class="pre">Motif</span></tt> 对象。第一步要先导入模体库：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">Motif</span>
</pre></div>
</div>
<p>然后可以开始创建第一个模体对象。创建一个DNA模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Motif</span><span class="o">.</span><span class="n">Motif</span><span class="p">(</span><span class="n">alphabet</span><span class="o">=</span><span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
</pre></div>
</div>
<p>现在这里面什么也没有，往新建的模体加入一些序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_instance</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TATAA&quot;</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_instance</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TATTA&quot;</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_instance</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TATAA&quot;</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_instance</span><span class="p">(</span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TATAA&quot;</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span><span class="p">))</span>
</pre></div>
</div>
<p>现在我们有了一个完整的 <tt class="docutils literal"><span class="pre">Motif</span></tt> 实例，我们可以试着从中获取一些基本信息。先看看长度和一致序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">consensus</span><span class="p">()</span>
<span class="go">Seq(&#39;TATAA&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>对于DNA模体，我们还可以获得一个模体的反向互补序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span><span class="o">.</span><span class="n">consensus</span><span class="p">()</span>
<span class="go">Seq(&#39;TTATA&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">i</span>
<span class="go">TTATA</span>
<span class="go">TAATA</span>
<span class="go">TTATA</span>
<span class="go">TTATA</span>
</pre></div>
</div>
<p>我们也可以简单的调取模体的信息容量：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;</span><span class="si">%0.2f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">ic</span><span class="p">()</span>
<span class="go">5.27</span>
</pre></div>
</div>
<p>这给我们提供了模体中信息容量的比特数，这指出和背景有多少不同。</p>
<p>展示模体最常用的就是PWM（位置仅重矩阵）。它概括了在模体上任意位置出现一个符号（这里指核苷酸）的概率。这个可以用 <tt class="docutils literal"><span class="pre">.pwm()</span></tt> 方法来计算：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">pwm</span><span class="p">()</span>
<span class="go">[{&#39;A&#39;: 0.05, &#39;C&#39;: 0.05, &#39;T&#39;: 0.85, &#39;G&#39;: 0.05},</span>
<span class="go"> {&#39;A&#39;: 0.85, &#39;C&#39;: 0.05, &#39;T&#39;: 0.05, &#39;G&#39;: 0.05},</span>
<span class="go"> {&#39;A&#39;: 0.05, &#39;C&#39;: 0.05, &#39;T&#39;: 0.85, &#39;G&#39;: 0.05},</span>
<span class="go"> {&#39;A&#39;: 0.65, &#39;C&#39;: 0.05, &#39;T&#39;: 0.25, &#39;G&#39;: 0.05},</span>
<span class="go"> {&#39;A&#39;: 0.85, &#39;C&#39;: 0.05, &#39;T&#39;: 0.05, &#39;G&#39;: 0.05}]</span>
</pre></div>
</div>
<p>模体的PWM中的概率是基于实例中的计数，但我们发现，虽然模体中没有出现G和C，可是它们的概率仍然是非0的。这主要是因为有伪计数的存在，简单地说，就是一种常用的方式来承认我们认知的不完备以及为了避免使用0进行对数运算而出现的技术问题。</p>
<p>我可以调整伪计数添加到模体对象两个属性的方式。 <tt class="docutils literal"><span class="pre">.background</span></tt> 是我们假设代表背景分布的所有字符的概率分布，是非模体序列（通常基于各自基因组的GC含量）。在模体创建的时候，就默认的设置为一个统一分布：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">background</span>
<span class="go">{&#39;A&#39;: 0.25, &#39;C&#39;: 0.25, &#39;T&#39;: 0.25, &#39;G&#39;: 0.25}</span>
</pre></div>
</div>
<p>另一个就是 <tt class="docutils literal"><span class="pre">.beta</span></tt> ，这个参数可以说明我们应该给伪计数设定为何值。默认设定为1.0。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">beta</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>所以输入伪计数的总量等于一个实例的输入总量。</p>
<p>使用背景分布和附加了伪计数的pwm，可以很容易的计算log-odd比率，这告诉我们在背景下，一个来自模体特定碱基的log-odd值。我们可以使用 <tt class="docutils literal"><span class="pre">.log_odds()</span></tt> 方法：</p>
<div class="code python highlight-python"><pre> &gt;&gt;&gt; m.log_odds()
[{'A': -2.3219280948873622,
  'C': -2.3219280948873622,
  'T': 1.7655347463629771,
  'G': -2.3219280948873622},
 {'A': 1.7655347463629771,
  'C': -2.3219280948873622,
  'T': -2.3219280948873622,
  'G': -2.3219280948873622},
 {'A': -2.3219280948873622,
  'C': -2.3219280948873622,
  'T': 1.7655347463629771,
  'G': -2.3219280948873622},
 {'A': 1.3785116232537298,
  'C': -2.3219280948873622,
  'T': 0.0,
  'G': -2.3219280948873622},
 {'A': 1.7655347463629771,
  'C': -2.3219280948873622,
  'T': -2.3219280948873622,
  'G': -2.3219280948873622}
]</pre>
</div>
<p>此处，我们可以看出如果模体中的碱基比背景中出现频率更高，其值为正值，反之则为负值。0.0说明在背景和模体中出现的概率是相同的（如第二个位置的“T”）。</p>
<div class="section" id="id16">
<h4>14.9.1.1  模体读写<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>手动从实例创建一个模体确实没什么技术含量，所以很有必要有一些读写功能来读取和写出模体。对于如何存储模体还没有一个固定的标准，但是有一些格式比其他格式更流行。这些格式的主要区别在于模体的创建是基于实例还是一些PWM矩阵。其中一个最流行的模体数据库就是 <a class="reference external" href="http://jaspar.genereg.net">JASPAR</a> ，该数据库保存了上述两种类型的格式，所以让我们看看是如何从实例中导入JASPAR模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">Motif</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arnt</span> <span class="o">=</span> <span class="n">Motif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;Arnt.sites&quot;</span><span class="p">),</span><span class="s">&quot;jaspar-sites&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>从一个计数矩阵中导入：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">srf</span> <span class="o">=</span> <span class="n">Motif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;SRF.pfm&quot;</span><span class="p">),</span><span class="s">&quot;jaspar-pfm&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">arnt</span></tt> 和 <tt class="docutils literal"><span class="pre">srf</span></tt> 模体可以为我们做相同的事情，但是它们使用不同的内部表现形式来展现模体。我们可以用 <tt class="docutils literal"><span class="pre">has_counts</span></tt> 和 <tt class="docutils literal"><span class="pre">has_instances</span></tt> 属性来区分它们：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arnt</span><span class="o">.</span><span class="n">has_instances</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">srf</span><span class="o">.</span><span class="n">has_instances</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">srf</span><span class="o">.</span><span class="n">has_counts</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">srf</span><span class="o">.</span><span class="n">counts</span>
<span class="go">{&#39;A&#39;: [2, 9, 0, 1, 32, 3, 46, 1, 43, 15, 2, 2],</span>
<span class="go"> &#39;C&#39;: [1, 33, 45, 45, 1, 1, 0, 0, 0, 1, 0, 1],</span>
<span class="go"> &#39;G&#39;: [39, 2, 1, 0, 0, 0, 0, 0, 0, 0, 44, 43],</span>
<span class="go"> &#39;T&#39;: [4, 2, 0, 0, 13, 42, 0, 45, 3, 30, 0, 0]}</span>
</pre></div>
</div>
<p>对于模体的不同表现形式，可以用转换功能来实现相互转换：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arnt</span><span class="o">.</span><span class="n">make_counts_from_instances</span><span class="p">()</span>
<span class="go">{&#39;A&#39;: [8, 38, 0, 0, 0, 0],</span>
<span class="go"> &#39;C&#39;: [32, 0, 40, 0, 0, 0],</span>
<span class="go"> &#39;G&#39;: [0, 2, 0, 40, 0, 40],</span>
<span class="go"> &#39;T&#39;: [0, 0, 0, 0, 40, 0]}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">srf</span><span class="o">.</span><span class="n">make_instances_from_counts</span><span class="p">()</span>
<span class="go">[Seq(&#39;GGGAAAAAAAGG&#39;, IUPACUnambiguousDNA()),</span>
<span class="go"> Seq(&#39;GGCCAAATAAGG&#39;, IUPACUnambiguousDNA()),</span>
<span class="go"> Seq(&#39;GACCAAATAAGG&#39;, IUPACUnambiguousDNA()),</span>
<span class="go">....</span>
</pre></div>
</div>
<p>在这里需要注意的是 <tt class="docutils literal"><span class="pre">make_instances_from_counts()</span></tt> 方法创建的是假实例，因为按照相同的pwm能够得到许多不同的实例，所以不能反过来重建原来的矩阵。不过这对我们利用PWM来展现模体没有什么影响，但从基于计数的模体中导出实例时要小心。</p>
<p>说到导出，让我们看看导出函数。我们可以按fasta的格式导出：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">m</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;fasta&quot;</span><span class="p">)</span>
<span class="go">&gt;instance0</span>
<span class="go">TATAA</span>
<span class="go">&gt;instance1</span>
<span class="go">TATTA</span>
<span class="go">&gt;instance2</span>
<span class="go">TATAA</span>
<span class="go">&gt;instance3</span>
<span class="go">TATAA</span>
</pre></div>
</div>
<p>或者是按TRANSFAC样的矩阵格式导出（能被一些处理软件识别）</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">m</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;transfac&quot;</span><span class="p">)</span>
<span class="go">XX</span>
<span class="go">TY Motif</span>
<span class="go">ID</span>
<span class="go">BF undef</span>
<span class="go">P0 G A T C</span>
<span class="go">01 0 0 4 0</span>
<span class="go">02 0 4 0 0</span>
<span class="go">03 0 0 4 0</span>
<span class="go">04 0 3 1 0</span>
<span class="go">05 0 4 0 0</span>
<span class="go">XX</span>
</pre></div>
</div>
<p>最后，如果能够联网，我们可以创建一个 <a class="reference external" href="http://weblogo.berkeley.edu">weblogo</a> ：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arnt</span><span class="o">.</span><span class="n">weblogo</span><span class="p">(</span><span class="s">&quot;Arnt.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>我们可以把得到的标识图以png的格式保存到特定的文件中。</p>
</div>
</div>
<div class="section" id="id17">
<h3>14.9.2  查找实例<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>模体中最常用的就是在一些序列中查找实例。为解释这部分，我们将手动创建一个如下的序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">test_seq</span><span class="o">=</span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;TATGATGTAGTATAATATAATTATAA&quot;</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">alphabet</span><span class="p">)</span>
</pre></div>
</div>
<p>查找实例最简单的方法就是在模体中查找具体匹配的实例：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">seq</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">search_instances</span><span class="p">(</span><span class="n">test_seq</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">pos</span><span class="p">,</span><span class="n">seq</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">10 TATAA</span>
<span class="go">15 TATAA</span>
<span class="go">21 TATAA</span>
</pre></div>
</div>
<p>对于互补序列，也可以用相同的方法（为了找到互补链上的实例）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">seq</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span><span class="o">.</span><span class="n">search_instances</span><span class="p">(</span><span class="n">test_seq</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">pos</span><span class="p">,</span><span class="n">seq</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">12 TAATA</span>
<span class="go">20 TTATA</span>
</pre></div>
</div>
<p>提高模体的log-odds值能让查为位置更加简单:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">score</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">search_pwm</span><span class="p">(</span><span class="n">test_seq</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">pos</span><span class="p">,</span><span class="n">score</span>
<span class="gp">...</span>
<span class="go">10 8.44065060871</span>
<span class="go">-12 7.06213898545</span>
<span class="go">15 8.44065060871</span>
<span class="go">-20 8.44065060871</span>
<span class="go">21 8.44065060871</span>
</pre></div>
</div>
<p>你可能注意到阀值参数，在这里随意地设为5.0。按 <em>log</em><sub>2</sub> 来算，我们应当查找那些在模体中出现概率为背景中出现概率32倍的序列。默认的阀值是0.0,在些阀值下，会把所有比背景中出现概率大的模体实例都找出来。</p>
<p>如果不想那么随意的选择一个阀值，你可以研究一下 <tt class="docutils literal"><span class="pre">Motif.score_distribution</span></tt> 类，它为模体提供一个相应的得分分布。由于得分的空间分布随着模体长度而成倍增长，我们正用一个近似于给定精度值计算，从而使计算成本易于控制：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sd</span> <span class="o">=</span> <span class="n">Motif</span><span class="o">.</span><span class="n">score_distribution</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>上面那个sd对象可以用来决定许多不同的阀值。</p>
<p>我们可以设定一个需要的假阳性率（找到一个由此序列在这个背景下产生的模体实例的概率）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sd</span><span class="o">.</span><span class="n">threshold_fpr</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="go">4.3535838726139886</span>
</pre></div>
</div>
<p>或者假阴性率（找不到模体产生的实例的概率）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sd</span><span class="o">.</span><span class="n">threshold_fnr</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">0.26651713652234044</span>
</pre></div>
</div>
<p>或者一个阀值（近似），满足假阳性率和假阴性率之间的关系（fnr/fpr≃ <em>t</em>)：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sd</span><span class="o">.</span><span class="n">threshold_balanced</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">8.4406506087056368</span>
</pre></div>
</div>
<p>或者一个阀值能够大体满足假阳性率和信息含量的 −<em>log</em> 值之间的相等关系（像Hertz和Stormo的Patser软件所用的一样）：</p>
<p>在我们这个例子中，当以1000比率的平衡阀值查找实例时，你可以得到一个让你获得相同结果（对于这个序列来说）的阀值：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pos</span><span class="p">,</span><span class="n">score</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">search_pwm</span><span class="p">(</span><span class="n">test_seq</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="n">sd</span><span class="o">.</span><span class="n">threshold_balanced</span><span class="p">(</span><span class="mi">1000</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">pos</span><span class="p">,</span><span class="n">score</span>
<span class="gp">...</span>
<span class="go">10 8.44065060871</span>
<span class="go">15 8.44065060871</span>
<span class="go">-20 8.44065060871</span>
<span class="go">21 8.44065060871</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h3>14.9.3  模体比较<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>当有多个模体时，我们就会想去比较他们。对此， <tt class="docutils literal"><span class="pre">Bio.Motif</span></tt> 有三种不同的方法来进行模体比较。</p>
<p>在我们开始比较之前，应当指出模体的边界通常是相当模糊的。也就是说我们经常需要比较不同长度的模体，因此这些比较涉及到相关的比对。所以我们需要考虑两个要点：</p>
<ul class="simple">
<li>模体比对</li>
<li>比较比对后模体的相关函数</li>
</ul>
<p>在 <tt class="docutils literal"><span class="pre">Bio.Motif</span></tt> 中有三种比较方法，这些方法都是基于来源于模体比对的想法，而采用不同方式。简单来说，我们使用不含间隔的PSSMs比对，并且用0来代替矩阵同背景相比，在开始和结束位置出现缺失的列。这三种比较方法都可以解释成距离估量，但是只有一个（ <tt class="docutils literal"><span class="pre">dist——dpq</span></tt> ）满足三角不等式。这些方法都返回距离的最小值和模体相应的偏移量。</p>
<p>为了展示这些比较功能是如何实现的，导入和测试模体 <tt class="docutils literal"><span class="pre">m</span></tt> 相似的其他模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ubx</span><span class="o">=</span><span class="n">Motif</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;Ubx.pfm&quot;</span><span class="p">),</span><span class="s">&quot;jaspar-pfm&quot;</span><span class="p">)</span>
<span class="go">&lt;Bio.Motif.Motif.Motif object at 0xc29b90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ubx</span><span class="o">.</span><span class="n">consensus</span><span class="p">()</span>
<span class="go">Seq(&#39;TAAT&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>第一个展示的功能是基于皮尔逊相关（Pearson correlation）的。因为我们想让它类似于一个距离估量，所以我们实际上取 1−<em>r</em> ，其中的 <em>r</em> 是皮尔逊相关系数（Pearson correlation coefficient，PCC）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">dist_pearson</span><span class="p">(</span><span class="n">ubx</span><span class="p">)</span>
<span class="go">(0.41740393308237722, 2)</span>
</pre></div>
</div>
<p>这意味着模体 <tt class="docutils literal"><span class="pre">m</span></tt> 和 <tt class="docutils literal"><span class="pre">Ubx</span></tt> 间最佳的PCC可以从下面的比对中获得：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">bbTAAT</span>
<span class="n">TATAAb</span>
</pre></div>
</div>
<p>其中 <tt class="docutils literal"><span class="pre">b</span></tt> 代表背景分布。PCC值大概为 1-0.42=0.58.如果我们尝试计算Ubx模体的互补序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">dist_pearson</span><span class="p">(</span><span class="n">ubx</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())</span>
<span class="go">(0.25784180151584823, 1)</span>
</pre></div>
</div>
<p>我们可以发现更好的PCC值（大概为0.75），并且比对也是不同的：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">bATTA</span>
<span class="n">TATAA</span>
</pre></div>
</div>
<p>还有两个其他的功能函数： <tt class="docutils literal"><span class="pre">dist_dpq</span></tt> ,这是基于Kullback-Leibler散度的真正度量（满足三角不等式）。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">dist_dpq</span><span class="p">(</span><span class="n">ubx</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())</span>
<span class="go">(0.49292358382899853, 1)</span>
</pre></div>
</div>
<p>还有 <tt class="docutils literal"><span class="pre">dist_product</span></tt> 方法，它是基于概率的方法，这概率可以看成是两个模体独立产生两个相同实例的概率。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">dist_product</span><span class="p">(</span><span class="n">ubx</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">())</span>
<span class="go">(0.16224587301064275, 1)</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>14.9.4  <em>De novo</em> 模体查找<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>目前，Biopython对 <em>de novo</em> 模体查找只有一些有限的支持。也就是说，我们只支持AlignAce和MEME的运行和读取。由于现模体查找工具发展如雨后春笋般，我们很欢迎有新的贡献者加入。</p>
<div class="section" id="id20">
<h4>14.9.4.1  MEME<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>假如你以中意的参数用MEME来跑你自己的序列，并把得到的结果保存在 <tt class="docutils literal"><span class="pre">meme.out</span></tt> 文件中。你可以用以下代码读取MEME产生的文件获得那些模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Motif</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;meme.out&quot;</span><span class="p">),</span><span class="s">&quot;MEME&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span>
<span class="go">[&lt;Bio.Motif.MEMEMotif.MEMEMotif object at 0xc356b0&gt;]</span>
</pre></div>
</div>
<p>除了那一系列想要的模体外，结果对象中还有很多有用的信息，可以用那些一目了然的属性名来获取：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">.alphabet</span></tt></li>
<li><tt class="docutils literal"><span class="pre">.datafile</span></tt></li>
<li><tt class="docutils literal"><span class="pre">.sequence_names</span></tt></li>
<li><tt class="docutils literal"><span class="pre">.version</span></tt></li>
<li><tt class="docutils literal"><span class="pre">.command</span></tt></li>
</ul>
<p>MEME解析器得到的模体可以像通常模体（含有实例）一样进行处理，它们也可以通过对实例添加附加信息而提供一些额外的功能。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">consensus</span><span class="p">()</span>
<span class="go">Seq(&#39;CTCAATCGTA&#39;, IUPACUnambiguousDNA())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pvalue</span>
<span class="go">8.71e-07</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sequence_name</span>
<span class="go">&#39;SEQ10;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strand</span>
<span class="go">&#39;+&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4>14.9.4.2  AlignAce<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>对于AlignACE程序也可以做相同的事情。假如你把结果存储于文件 <tt class="docutils literal"><span class="pre">alignace.out</span></tt> 文件中。你可以用以下代码读取结果：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsA</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">Motif</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&quot;alignace.out&quot;</span><span class="p">),</span><span class="s">&quot;AlignAce&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>同样，得到的模体也和平常的模体一样：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">consensus</span><span class="p">()</span>
<span class="go">Seq(&#39;TCTACGATTGAG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>事实上，你甚至可以发现AlignAce和MEME得到的模体十分相似，只不过AlignAce模体是MEME模体反向互补序列的加长版本而已：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">motifsM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span><span class="o">.</span><span class="n">consensus</span><span class="p">()</span>
<span class="go">Seq(&#39;TACGATTGAG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>如果你的机器上安装了AlignAce，你也可以直接从Biopython中启动。下面就是一个如何启动的小例子（其他参数可以用关键字参数指定）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">command</span><span class="o">=</span><span class="s">&quot;/opt/bin/AlignACE&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">input_file</span><span class="o">=</span><span class="s">&quot;test.fa&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Motif.Applications</span> <span class="kn">import</span> <span class="n">AlignAceCommandline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmd</span> <span class="o">=</span> <span class="n">AlignAceCommandline</span><span class="p">(</span><span class="n">cmd</span><span class="o">=</span><span class="n">command</span><span class="p">,</span><span class="nb">input</span><span class="o">=</span><span class="n">input_file</span><span class="p">,</span><span class="n">gcback</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span><span class="n">numcols</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stdout</span><span class="p">,</span><span class="n">stderr</span><span class="o">=</span> <span class="n">cmd</span><span class="p">()</span>
</pre></div>
</div>
<p>由于AlignAce把结果打印到标准输出，因此你可以通过读取结果的第一部分来获得你想要的模体：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">motifs</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">Motif</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span><span class="s">&quot;AlignAce&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">第14章   使用Bio.motifs进行模体序列分析</a><ul>
<li><a class="reference internal" href="#id1">14.1  模体对象</a><ul>
<li><a class="reference internal" href="#id2">14.1.1  从实例中创建一个模体</a></li>
<li><a class="reference internal" href="#id3">14.1.2  读取模体</a><ul>
<li><a class="reference internal" href="#jaspar">JASPAR</a></li>
<li><a class="reference internal" href="#meme">MEME</a></li>
<li><a class="reference internal" href="#mast">MAST</a></li>
<li><a class="reference internal" href="#transfac">TRANSFAC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">14.1.3  模体写出</a></li>
<li><a class="reference internal" href="#id5">14.1.4  绘制序列标识图</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">14.2  位置权重矩阵</a></li>
<li><a class="reference internal" href="#id7">14.3  位置特异性得分矩阵</a></li>
<li><a class="reference internal" href="#id8">14.4  搜索实例</a><ul>
<li><a class="reference internal" href="#id9">14.4.1  搜索准确匹配实例</a></li>
<li><a class="reference internal" href="#pssm">14.4.2  用PSSM得分搜索匹配实例</a></li>
<li><a class="reference internal" href="#id10">14.4.3  选择得分阀值</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">14.5  模体对象自身相关的位置特异性得分矩阵</a></li>
<li><a class="reference internal" href="#id12">14.6  模体比较</a></li>
<li><a class="reference internal" href="#de-novo">14.7  查找 <em>De novo</em> 模体</a><ul>
<li><a class="reference internal" href="#id13">14.7.1  MEME</a></li>
<li><a class="reference internal" href="#alignace">14.7.2  AlignAce</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sec-links">14.8  相关链接</a></li>
<li><a class="reference internal" href="#bio-motif">14.9  旧版Bio.Motif模块</a><ul>
<li><a class="reference internal" href="#id15">14.9.1  模体对象</a><ul>
<li><a class="reference internal" href="#id16">14.9.1.1  模体读写</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">14.9.2  查找实例</a></li>
<li><a class="reference internal" href="#id18">14.9.3  模体比较</a></li>
<li><a class="reference internal" href="#id19">14.9.4  <em>De novo</em> 模体查找</a><ul>
<li><a class="reference internal" href="#id20">14.9.4.1  MEME</a></li>
<li><a class="reference internal" href="#id21">14.9.4.2  AlignAce</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chr13.html"
                        title="previous chapter">第13章  Bio.Phylo系统发育分析</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chr15.html"
                        title="next chapter">第15章 聚类分析</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chr14.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chr15.html" title="第15章 聚类分析"
             >next</a> |</li>
        <li class="right" >
          <a href="chr13.html" title="第13章 Bio.Phylo系统发育分析"
             >previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, biopythoners.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>