<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第3章 生物序列对象 &mdash; biopython_cn 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="biopython_cn 0.1 documentation" href="index.html" />
    <link rel="next" title="第4章 序列注释对象" href="chr04.html" />
    <link rel="prev" title="第2章 快速开始 —— 你能用Biopython做什么？" href="chr02.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chr04.html" title="第4章 序列注释对象"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chr02.html" title="第2章 快速开始 —— 你能用Biopython做什么？"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-bio-seq">
<span id="id1"></span><h1>第3章     生物序列对象<a class="headerlink" href="#chapter-bio-seq" title="Permalink to this headline">¶</a></h1>
<p>生物学序列以绝对的优势成为生物信息学研究的重点对象。这一章我们将简要介绍
Biopython处理这些序列的机制&#8211; <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象。第 <a class="reference internal" href="chr04.html#chapter-seqrecord"><em>4</em></a>
章将要引入与此相关的 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> 对象，此对象可以将序列信息和注释结合起来，
用于第 <a class="reference internal" href="chr05.html#chapter-bio-seqio"><em>5</em></a> 章序列的输入/输出。</p>
<p>序列实质上就是由字母构成的字符串，比如 <tt class="docutils literal"><span class="pre">AGTACACTGGT</span></tt> ，看起来很自然，因为
这就是序列在生物学文件中的常用代表格式。</p>
<p><tt class="docutils literal"><span class="pre">Seq</span></tt> 对象和标准的Python字符串有两个明显的不同。首先，它们使用不同的方法。
尽管``Seq``对象支持常规字符串的很多方法，但是它的 <tt class="docutils literal"><span class="pre">translate()</span></tt> 方法在做
生物学翻译时是不同的。相似的还有其他的生物学相关的方法，比如 <tt class="docutils literal"><span class="pre">reverse_complement()</span></tt> 。
其次， <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象具有一个重要的属性&#8211; <tt class="docutils literal"><span class="pre">alphabet</span></tt> ，这一对象用于描述由单个
字母构成的序列字符串的 “mean” （意义），以及如何解释这一字符串。例如， <tt class="docutils literal"><span class="pre">AGTACACTGGT</span></tt>
序列是个DNA序列还是一段富含Alanines, Glycines, Cysteines and Threonines
的蛋白质序列？</p>
<div class="section" id="id2">
<h2>3.1  序列和字母表<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>字母对象可能是使得``Seq``对象不仅仅是字符串的重要因素。目前，Biopython的字母表
定义在``Bio.Alphabet``模块。我们将会使用IUPAC字母表
（ <a class="reference external" href="http://www.chem.qmw.ac.uk/iupac/">http://www.chem.qmw.ac.uk/iupac/</a> ）
来处理我们比较青睐的对象：DNA、RNA和蛋白质对象。</p>
<p><tt class="docutils literal"><span class="pre">Bio.Alphabet.IUPAC</span></tt> 提供了蛋白质、DNA和RNA的基本定义，并且提供了扩展
和定制基本定义的功能。例如蛋白质，有一个基本的IUPACProtein类，另外还有
一个ExtendedIUPACProtein类。这个类包含除20种常见氨基酸外的其他氨基酸元素，
比如 “U” （或 “Sec”代表硒代半胱氨酸），“O”（或“Pyl” 代表吡咯赖氨酸），
还有歧意字母“B” （或“Asx”代表天冬酰胺或者天冬氨酸），“Z”（或“Glx”代表谷
氨酰胺或者谷氨酸），“J” （或“Xle”代表亮氨酸或异亮氨酸），“X” （或“Xxx”代
表未知氨基酸）。同理，对于DNA有IUPACUnambiguousDNA、IUPACAmbiguousDNA和
ExtendedIUPACDNA类，分别提供基本字母，每种可能下的歧意字母和修饰后的碱基。
同样地，RNA可以使用IUPACAmbiguousRNA和IUPACUnambiguousRNA类。</p>
<p>使用字母表类有两方面的优势。首先，明确了Seq对象包含的信息的类型；其次通过
类型检查，它提供了约束信息的工具。</p>
<p>我们已经知道了将要处理的对象，现在让我们看看怎么使用这些类做一些有意思的事情。
你可以创建一条有通用字母组成的模糊序列，如下：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AGTACACTGGT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span>
<span class="go">Seq(&#39;AGTACACTGGT&#39;, Alphabet())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="o">.</span><span class="n">alphabet</span>
<span class="go">Alphabet()</span>
</pre></div>
</div>
<p>然而，如果可能，你要在创建序列对象的时候就尽量明确指定字母的类型，如下创建一条
明确的DNA字母表对象。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AGTACACTGGT&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span>
<span class="go">Seq(&#39;AGTACACTGGT&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="o">.</span><span class="n">alphabet</span>
<span class="go">IUPACUnambiguousDNA()</span>
</pre></div>
</div>
<p>当然,除非这真的是一个氨基酸序列：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_prot</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AGTACACTGGT&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_prot</span>
<span class="go">Seq(&#39;AGTACACTGGT&#39;, IUPACProtein())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_prot</span><span class="o">.</span><span class="n">alphabet</span>
<span class="go">IUPACProtein()</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>3.2  序列表现的像字符串一样<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>在许多时候，我们可以讲Seq对象处理成正常的Python字符串，比如取序列长度，迭代
元素：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;GATCG&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">letter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">my_seq</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">index</span><span class="p">,</span> <span class="n">letter</span>
<span class="go">0 G</span>
<span class="go">1 A</span>
<span class="go">2 T</span>
<span class="go">3 C</span>
<span class="go">4 G</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_seq</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>你可以像字符串那样获取序列的元素（但是请记住，Python计数从0开始）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">my_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#first letter</span>
<span class="go">G</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">my_seq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c">#third letter</span>
<span class="go">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">my_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c">#last letter</span>
<span class="go">G</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Seq</span></tt> 对象有一个 <tt class="docutils literal"><span class="pre">.count()</span></tt> 方法，类似于字符串。记住这意味就像Python的
字符串一样进行着非重叠的计数。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;AAAA&quot;</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;AA&quot;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AAAA&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;AA&quot;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>但是在某些生物学上，你可能需要使用重叠计数（就像上面的例子中如果重复计
数结果将为3）。当计算耽搁字母出现的次数时，重叠计数和非重叠计数没有差别。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&#39;GATCGATGGGCCTATATAGGATCGAAAATCGC&#39;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">my_seq</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;G&quot;</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">100</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">my_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;G&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">my_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_seq</span><span class="p">)</span>
<span class="go">46.875</span>
</pre></div>
</div>
<p>你当然可以使用上面的代码段计算GC含量，但是记住 <tt class="docutils literal"><span class="pre">Bio.SeqUtils</span></tt> 模块已经
建立了好几个GC函数，类如：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.SeqUtils</span> <span class="kn">import</span> <span class="n">GC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&#39;GATCGATGGGCCTATATAGGATCGAAAATCGC&#39;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GC</span><span class="p">(</span><span class="n">my_seq</span><span class="p">)</span>
<span class="go">46.875</span>
</pre></div>
</div>
<p>注意在使用 <tt class="docutils literal"><span class="pre">Bio.SeqUtils.GC()</span></tt> 函数时会自动处理序列和可代表G或者C的歧意核苷酸
字母S混合的情况。</p>
<p>然后还要注意，就像正常的Python字符串， <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象在某些方式下是只读的。如果需要
编辑序列，比如模拟点突变，请看后续的 <a class="reference internal" href="#sec-mutable-seq"><em>3.12</em></a> 章节中讲述的
<tt class="docutils literal"><span class="pre">MutableSeq</span></tt> 对象。</p>
</div>
<div class="section" id="id4">
<h2>3.3  切取序列<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>一个较为复杂的例子，让我们切取序列。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;GATCGATGGGCCTATATAGGATCGAAAATCGC&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span>
<span class="go">Seq(&#39;GATGGGCC&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>要注意两个有意思的地方。首先，序列第一个元素从0开始，这是符合Python字符串的规则的。
这在计算机科学上是普遍现象，但在生物学上不是这样。当你做切片的时候，第一项包含了
（比如例子中的4），而最后一项去除了（例子中的12）。这是Python的规则，但当然这不是
世界上所有人都希望的。主要是为了和Python保持一致。</p>
<dl class="docutils">
<dt>第二个需要注意的地方是，切片是在序列数据字符串上执行的，但是产生的新对象保留了原始</dt>
<dd><tt class="docutils literal"><span class="pre">Seq</span></tt> 对象的字母表信息。</dd>
</dl>
<p>同样和Python字符串一样，你可以通过设置起始位置、终止位置和 <em>步幅</em> （间隔数，默认为1）
进行切片。例如，我们可以分别获取下面DNA序列密码子第一、第二、第三位的碱基。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">Seq(&#39;GCTGTAGTAAG&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">Seq(&#39;AGGCATGCATC&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">Seq(&#39;TAGCTAAGAC&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>你可能已经注意到Python字符串中的另一个奇特步幅设定：使用-1返回倒序字符串切片。
当然以也可以使用 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象来完成。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Seq(&#39;CGCTAAAAGCTAGGATATATCCGGGTAGCTAG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
</div>
<div class="section" id="sec-seq-to-string">
<span id="id5"></span><h2>3.4  将序列对象转换成字符串<a class="headerlink" href="#sec-seq-to-string" title="Permalink to this headline">¶</a></h2>
<p>如果你仅仅需要一个单纯的字符串，就像写入文件或者插入数据库，这事很容易就
可以实现的：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">my_seq</span><span class="p">)</span>
<span class="go">&#39;GATCGATGGGCCTATATAGGATCGAAAATCGC&#39;</span>
</pre></div>
</div>
<p>尽管对 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象调用 <tt class="docutils literal"><span class="pre">str()</span></tt> 方法将以字符串的形式返回全长序列，但是你经常不需要
特地做这个转换。当使用print打印声明是，Python会自动转换。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">my_seq</span>
<span class="go">GATCGATGGGCCTATATAGGATCGAAAATCGC</span>
</pre></div>
</div>
<p>当你进行Python字符串格式化或者插入操作符（ <tt class="docutils literal"><span class="pre">%</span></tt> ）时，
可以直接把 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象和 <tt class="docutils literal"><span class="pre">%s</span></tt> 占位符一起使用：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fasta_format_string</span> <span class="o">=</span> <span class="s">&quot;&gt;Name</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">my_seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">fasta_format_string</span>
<span class="go">&gt;Name</span>
<span class="go">GATCGATGGGCCTATATAGGATCGAAAATCGC</span>
</pre></div>
</div>
<p>这一行代码展示的是一个简单的FASTA格式的记录（不用关心自动换行）。
<a class="reference internal" href="chr04.html#sec-seqrecord-format"><em>4.5</em></a> 部分将介绍一个简洁的方式从 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt>
对象中获取FASTA格式的字符串，更详细的读写FASTA格式的序列文件将在第
<a class="reference internal" href="chr05.html#chapter-bio-seqio"><em>5</em></a> 章介绍。</p>
<p><em>注意：</em>  如果你使用Biopython 1.44或者更旧的版本，使用 <tt class="docutils literal"><span class="pre">str(my_seq)</span></tt> 只会
返回一个截短了的序列。这时候可以使用 <tt class="docutils literal"><span class="pre">my_seq.tostring()</span></tt> ，为了保持向后兼
容性，这一方法在当前的Biopython版本中还有保留。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>
<span class="go">&#39;GATCGATGGGCCTATATAGGATCGAAAATCGC&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>3.5  连接或添加序列<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>当然，原则上你可以将任何两个Seq对象加在一起，就像Python字符串一样去连接它们。
但是你不能将两个不相容的字母表加在一起，比如蛋白质序列和核苷酸序列就不能简单
叠加。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">protein_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;EVRNAK&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;ACGT&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">protein_seq</span> <span class="o">+</span> <span class="n">dna_seq</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Incompatible alphabets IUPACProtein() and IUPACUnambiguousDNA()</span>
</pre></div>
</div>
<p>如果你 <em>真的</em> 想这么做，你必须首先将两个序列转换成通用字母表。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">generic_alphabet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">protein_seq</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">generic_alphabet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">generic_alphabet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">protein_seq</span> <span class="o">+</span> <span class="n">dna_seq</span>
<span class="go">Seq(&#39;EVRNAKACGT&#39;, Alphabet())</span>
</pre></div>
</div>
<p>这里有个例子是将通用核苷酸序列加到明确的IUPAC DNA序列上，最后生成一段
模糊的核苷酸序列。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">generic_nucleotide</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nuc_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;GATCGATGC&quot;</span><span class="p">,</span> <span class="n">generic_nucleotide</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;ACGT&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nuc_seq</span>
<span class="go">Seq(&#39;GATCGATGC&#39;, NucleotideAlphabet())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span>
<span class="go">Seq(&#39;ACGT&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nuc_seq</span> <span class="o">+</span> <span class="n">dna_seq</span>
<span class="go">Seq(&#39;GATCGATGCACGT&#39;, NucleotideAlphabet())</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>3.6  改变大小写<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Python字符串具有很有用的转换大小写的 <tt class="docutils literal"><span class="pre">upper</span></tt> 和 <tt class="docutils literal"><span class="pre">lower</span></tt> 方法。从
Biopython 1.53起， <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象也获取了类似的方法应用于字母表。例如:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">generic_dna</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;acgtACGT&quot;</span><span class="p">,</span> <span class="n">generic_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span>
<span class="go">Seq(&#39;acgtACGT&#39;, DNAAlphabet())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">Seq(&#39;ACGTACGT&#39;, DNAAlphabet())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">Seq(&#39;acgtacgt&#39;, DNAAlphabet())</span>
</pre></div>
</div>
<p>这在不区分大小写进行匹配的时候很有用。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;GTAC&quot;</span> <span class="ow">in</span> <span class="n">dna_seq</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&quot;GTAC&quot;</span> <span class="ow">in</span> <span class="n">dna_seq</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>注意，严格地说IUPAC字母表仅仅是对于大写字母构成的序列的，因此：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;ACGT&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span>
<span class="go">Seq(&#39;ACGT&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dna_seq</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">Seq(&#39;acgt&#39;, DNAAlphabet())</span>
</pre></div>
</div>
</div>
<div class="section" id="sec-seq-reverse-complement">
<span id="id8"></span><h2>3.7  核苷酸序列和（反向）互补序列<a class="headerlink" href="#sec-seq-reverse-complement" title="Permalink to this headline">¶</a></h2>
<p>对于核苷酸序列，你可以使用 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象内置的方法很容易地获得 <tt class="docutils literal"><span class="pre">Seq</span></tt>
的互补或反向互补序列。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;GATCGATGGGCCTATATAGGATCGAAAATCGC&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span>
<span class="go">Seq(&#39;GATCGATGGGCCTATATAGGATCGAAAATCGC&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="go">Seq(&#39;CTAGCTACCCGGATATATCCTAGCTTTTAGCG&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
<span class="go">Seq(&#39;GCGATTTTCGATCCTATATAGGCCCATCGATC&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>在前面的方法中，使用切片的-1的步长可以很容易的获取一个 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象的反向序列。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Seq(&#39;CGCTAAAAGCTAGGATATATCCGGGTAGCTAG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>在所有这些操作中，字母的属性一直保留着。这是非常有用的，以防你不小心做一些
奇怪的事情，比如获取蛋白质序列的（反向）互补序列。</p>
<div class="code python highlight-python"><pre>   &gt;&gt;&gt; from Bio.Seq import Seq
   &gt;&gt;&gt; from Bio.Alphabet import IUPAC
   &gt;&gt;&gt; protein_seq = Seq("EVRNAK", IUPAC.protein)
   &gt;&gt;&gt; protein_seq.complement()
   Traceback (most recent call last):
   ...
   ValueError: Proteins do not have complements!

 :ref:`5.5.3 &lt;sec-SeqIO-reverse-complement&gt;` 部分的例子将 ``Seq`` 对象的反向互补
方法和 ``Bio.SeqIO`` 对于序列的输入/输出方法结合起来。</pre>
</div>
</div>
<div class="section" id="id9">
<h2>3.8  转录<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>在谈论转录之前，我想先说明一下链的问题。考虑以下（编造的）编码短肽的双链DNA的延伸：</p>
<div class="math">
\[\begin{split}\begin{equation}
\\
   &amp; _{DNA coding strand (aka Crick strand, strand $+1$)} &amp; \\
5' &amp; \texttt{ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG} &amp; 3' \\
   &amp; \texttt{|||||||||||||||||||||||||||||||||||||||} &amp; \\
3' &amp; \texttt{TACCGGTAACATTACCCGGCGACTTTCCCACGGGCTATC} &amp; 5' \\
   &amp; _{DNA template strand (aka Watson strand, strand $-1$)} &amp; \\
\\
   &amp; {$|$} &amp;\\
   &amp; Transcription &amp; \\
   &amp; {$\downarrow$} &amp;\\
\\
5' &amp; \texttt{AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG} &amp; 3' \\
   &amp; _{Single stranded messenger RNA} &amp; \\
\\
\end{equation}\end{split}\]</div>
<p>实际的生物学上的转录过程是将模板链反向互补（TCAG → CUGA）生成mRNA。但是，
在Biopython和生物信息学领域，我们通常会直接利用编码链，因为我们可以通过
T → U的转换获得mRNA。</p>
<p>现在让我们着手真实地使用Biopython做一个转录。首先，让我们分别创建DNA序列的
编码链和模板链的 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span>
<span class="go">Seq(&#39;ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template_dna</span> <span class="o">=</span> <span class="n">coding_dna</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template_dna</span>
<span class="go">Seq(&#39;CTATCGGGCACCCTTTCAGCGGCCCATTACAATGGCCAT&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>这是和上面的图表相一致的，记住按照惯例核苷酸序列通常是从5’到3’端方向的，
而图中所示的模板链是反向的。</p>
<p>现在让我们使用 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象内置的 <tt class="docutils literal"><span class="pre">transcribe</span></tt> 方法将编码链转录成对应的mRNA：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span>
<span class="go">Seq(&#39;ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messenger_rna</span> <span class="o">=</span> <span class="n">coding_dna</span><span class="o">.</span><span class="n">transcribe</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messenger_rna</span>
<span class="go">Seq(&#39;AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG&#39;, IUPACUnambiguousRNA())</span>
</pre></div>
</div>
<p>就如你看到的，这里做的全部工作是将T → U转换，并调整字母表。</p>
<p>如果你确实想从模板链去做一个真正的生物学上的转录，需要两步：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">template_dna</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span><span class="o">.</span><span class="n">transcribe</span><span class="p">()</span>
<span class="go">Seq(&#39;AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG&#39;, IUPACUnambiguousRNA())</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Seq</span></tt> 对象还包含了从mRNA逆向转录为DNA编码链的方法。同样，这仅仅是从U
→ T的替代并伴随着字母表的变化：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messenger_rna</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_rna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messenger_rna</span>
<span class="go">Seq(&#39;AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG&#39;, IUPACUnambiguousRNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messenger_rna</span><span class="o">.</span><span class="n">back_transcribe</span><span class="p">()</span>
<span class="go">Seq(&#39;ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p><em>注意：</em> <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象的 <tt class="docutils literal"><span class="pre">transcribe</span></tt> 和 <tt class="docutils literal"><span class="pre">back_transcribe</span></tt> 方法直到
Biopython 1.49版本才出现，在较早的版本中你需要使用 <tt class="docutils literal"><span class="pre">Bio.Seq</span></tt> 模块的函
数替代，详见 <a class="reference internal" href="#sec-seq-module-functions"><em>3.14</em></a> 部分。</p>
</div>
<div class="section" id="sec-translation">
<span id="id10"></span><h2>3.9  翻译<a class="headerlink" href="#sec-translation" title="Permalink to this headline">¶</a></h2>
<p>继续使用在转录那个小节中的例子，现在让我们将这个mRNA翻译成相对应的
蛋白质序列，利用的是 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象众多生物学方法中的一个：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messenger_rna</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_rna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messenger_rna</span>
<span class="go">Seq(&#39;AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG&#39;, IUPACUnambiguousRNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messenger_rna</span><span class="o">.</span><span class="n">translate</span><span class="p">()</span>
<span class="go">Seq(&#39;MAIVMGR*KGAR*&#39;, HasStopCodon(IUPACProtein(), &#39;*&#39;))</span>
</pre></div>
</div>
<p>你也可以直接从编码DNA链进行翻译：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span>
<span class="go">Seq(&#39;ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">()</span>
<span class="go">Seq(&#39;MAIVMGR*KGAR*&#39;, HasStopCodon(IUPACProtein(), &#39;*&#39;))</span>
</pre></div>
</div>
<p>你应该注意到在上面的蛋白质序列中，除了末尾的终止符外，在序列中间还有一个终止符。
其实这是一个精心选择的例子，因为由它我们可以引申讲一下可选参数，包括不同的翻译
表（遗传密码）。</p>
<p>Biopython上可用的翻译表是基于 <a class="reference external" href="http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi">NCBI</a>
（参考这个教程的下一个部分）。默认情况下，翻译使用的是 <em>标准</em> 遗传密码（NCBI上table id 1)。
假设我们需要翻译一个线粒体序列，我们就需要告诉翻译函数使用相关的遗传密码：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="s">&quot;Vertebrate Mitochondrial&quot;</span><span class="p">)</span>
<span class="go">Seq(&#39;MAIVMGRWKGAR*&#39;, HasStopCodon(IUPACProtein(), &#39;*&#39;))</span>
</pre></div>
</div>
<p>你也可以利用NCBI上表格的标号来指定所使用的遗传密码，这样更简洁一些，
在GenBank文件的特征注释中经常包含表格的标号：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Seq(&#39;MAIVMGRWKGAR*&#39;, HasStopCodon(IUPACProtein(), &#39;*&#39;))</span>
</pre></div>
</div>
<p>现在你可能想将上面的核苷酸序列仅翻译到阅读框的第一个终止密码子，然后停止
（这更符合自然现象）。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">()</span>
<span class="go">Seq(&#39;MAIVMGR*KGAR*&#39;, HasStopCodon(IUPACProtein(), &#39;*&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">to_stop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Seq(&#39;MAIVMGR&#39;, IUPACProtein())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Seq(&#39;MAIVMGRWKGAR*&#39;, HasStopCodon(IUPACProtein(), &#39;*&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">to_stop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Seq(&#39;MAIVMGRWKGAR&#39;, IUPACProtein())</span>
</pre></div>
</div>
<p>注意到当你使用 <tt class="docutils literal"><span class="pre">to_stop</span></tt> 参数时，终止密码子本身是不翻译的，终止的符号也是
不显现在蛋白质序列中的。</p>
<p>如果你不喜欢默认的星号作为终止符号，你也可以自己指定终止符。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coding_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stop_symbol</span><span class="o">=</span><span class="s">&quot;@&quot;</span><span class="p">)</span>
<span class="go">Seq(&#39;MAIVMGRWKGAR@&#39;, HasStopCodon(IUPACProtein(), &#39;@&#39;))</span>
</pre></div>
</div>
<p>现在假设你有一条完整的编码序列CDS，这是一种核苷酸序列（例如mRNA剪切以后），
序列全长都是密码子（也就是长度是3的倍数），开始于起始密码子，终止于终止密
码子，阅读框内没有内部的终止密码子。通常情况下，给你一条完整的CDS，默认的
翻译方法即可以翻译出你想要的（有时使用 <tt class="docutils literal"><span class="pre">to_stop</span></tt> 选项）。但是，如果序列使
用的是非标准的起始密码子呢？这种情况在细菌中很常见，比如 <tt class="docutils literal"><span class="pre">E.</span> <span class="pre">coli</span></tt>
K12中的基因yaaX：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">generic_dna</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gene</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;GTGAAAAAGATGCAATCTATCGTACTCGCACTTTCCCTGGTTCTGGTCGCTCCCATGGCA&quot;</span> <span class="o">+</span> \
<span class="gp">... </span>           <span class="s">&quot;GCACAGGCTGCGGAAATTACGTTAGTCCCGTCAGTAAAATTACAGATAGGCGATCGTGAT&quot;</span> <span class="o">+</span> \
<span class="gp">... </span>           <span class="s">&quot;AATCGTGGCTATTACTGGGATGGAGGTCACTGGCGCGACCACGGCTGGTGGAAACAACAT&quot;</span> <span class="o">+</span> \
<span class="gp">... </span>           <span class="s">&quot;TATGAATGGCGAGGCAATCGCTGGCACCTACACGGACCGCCGCCACCGCCGCGCCACCAT&quot;</span> <span class="o">+</span> \
<span class="gp">... </span>           <span class="s">&quot;AAGAAAGCTCCTCATGATCATCACGGCGGTCATGGTCCAGGCAAACATCACCGCTAA&quot;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">generic_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gene</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="s">&quot;Bacterial&quot;</span><span class="p">)</span>
<span class="go">Seq(&#39;VKKMQSIVLALSLVLVAPMAAQAAEITLVPSVKLQIGDRDNRGYYWDGGHWRDH...HHR*&#39;,</span>
<span class="go">HasStopCodon(ExtendedIUPACProtein(), &#39;*&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gene</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="s">&quot;Bacterial&quot;</span><span class="p">,</span> <span class="n">to_stop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Seq(&#39;VKKMQSIVLALSLVLVAPMAAQAAEITLVPSVKLQIGDRDNRGYYWDGGHWRDH...HHR&#39;,</span>
<span class="go">ExtendedIUPACProtein())</span>
</pre></div>
</div>
<p>在细菌遗传密码中 <tt class="docutils literal"><span class="pre">GTG</span></tt> 是个有效的起始密码子。 <em>正常情况下</em> 编码缬氨酸，
如果作为起始密码子，则翻译成甲硫氨酸。当你告诉Biopython你的序列是完整CDS时，
这事将会发生。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gene</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="s">&quot;Bacterial&quot;</span><span class="p">,</span> <span class="n">cds</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">Seq(&#39;MKKMQSIVLALSLVLVAPMAAQAAEITLVPSVKLQIGDRDNRGYYWDGGHWRDH...HHR&#39;,</span>
<span class="go">ExtendedIUPACProtein())</span>
</pre></div>
</div>
<p>除了告诉Biopython翻译时使用另一种起始密码子编码甲硫氨酸外，使用这一选项同样能
确保你的序列是个真实有效的CDS（如果不是将会抛出异常）。</p>
<dl class="docutils">
<dt>第 <a class="reference internal" href="chr18.html#sec-seqio-translate"><em>18.1.3</em></a> 章的例子将把 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象的翻译方法和</dt>
<dd><tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> 对象的对于序列的输入/输出方法结合起来。</dd>
</dl>
</div>
<div class="section" id="id11">
<h2>3.10  翻译表<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>在前面的章节中我们讨论了 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象的转录方法（并且提到了 <tt class="docutils literal"><span class="pre">Bio.Seq</span></tt> 模块
中的等效函数&#8211;参见第 <a class="reference internal" href="#sec-seq-module-functions"><em>3.14</em></a> 章节）。实质上
使用的这些密码子表对象来自与NCBI的 <tt class="docutils literal"><span class="pre">`ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt</span></tt>
&lt;<a class="reference external" href="ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt">ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt</a>&gt;`__ ，还有
<a class="reference external" href="http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi">http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</a>
以一种更易读的形式呈现。</p>
<p>和前面一样，让我们仅仅关注两个选择：标准的翻译表和脊椎动物线粒体DNA的翻译表。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Data</span> <span class="kn">import</span> <span class="n">CodonTable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">standard_table</span> <span class="o">=</span> <span class="n">CodonTable</span><span class="o">.</span><span class="n">unambiguous_dna_by_name</span><span class="p">[</span><span class="s">&quot;Standard&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mito_table</span> <span class="o">=</span> <span class="n">CodonTable</span><span class="o">.</span><span class="n">unambiguous_dna_by_name</span><span class="p">[</span><span class="s">&quot;Vertebrate Mitochondrial&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>另一种方式，这些表也可以分别以标号1和2来标识：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Data</span> <span class="kn">import</span> <span class="n">CodonTable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">standard_table</span> <span class="o">=</span> <span class="n">CodonTable</span><span class="o">.</span><span class="n">unambiguous_dna_by_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mito_table</span> <span class="o">=</span> <span class="n">CodonTable</span><span class="o">.</span><span class="n">unambiguous_dna_by_id</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>你可以在打印后直观地比较这些实际的翻译表：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">standard_table</span>
<span class="go">Table 1 Standard, SGC0</span>

<span class="go">  |  T      |  C      |  A      |  G      |</span>
<span class="go">--+---------+---------+---------+---------+--</span>
<span class="go">T | TTT F   | TCT S   | TAT Y   | TGT C   | T</span>
<span class="go">T | TTC F   | TCC S   | TAC Y   | TGC C   | C</span>
<span class="go">T | TTA L   | TCA S   | TAA Stop| TGA Stop| A</span>
<span class="go">T | TTG L(s)| TCG S   | TAG Stop| TGG W   | G</span>
<span class="go">--+---------+---------+---------+---------+--</span>
<span class="go">C | CTT L   | CCT P   | CAT H   | CGT R   | T</span>
<span class="go">C | CTC L   | CCC P   | CAC H   | CGC R   | C</span>
<span class="go">C | CTA L   | CCA P   | CAA Q   | CGA R   | A</span>
<span class="go">C | CTG L(s)| CCG P   | CAG Q   | CGG R   | G</span>
<span class="go">--+---------+---------+---------+---------+--</span>
<span class="go">A | ATT I   | ACT T   | AAT N   | AGT S   | T</span>
<span class="go">A | ATC I   | ACC T   | AAC N   | AGC S   | C</span>
<span class="go">A | ATA I   | ACA T   | AAA K   | AGA R   | A</span>
<span class="go">A | ATG M(s)| ACG T   | AAG K   | AGG R   | G</span>
<span class="go">--+---------+---------+---------+---------+--</span>
<span class="go">G | GTT V   | GCT A   | GAT D   | GGT G   | T</span>
<span class="go">G | GTC V   | GCC A   | GAC D   | GGC G   | C</span>
<span class="go">G | GTA V   | GCA A   | GAA E   | GGA G   | A</span>
<span class="go">G | GTG V   | GCG A   | GAG E   | GGG G   | G</span>
<span class="go">--+---------+---------+---------+---------+--</span>
</pre></div>
</div>
<p>和</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">mito_table</span>
<span class="go">Table 2 Vertebrate Mitochondrial, SGC1</span>

<span class="go">  |  T      |  C      |  A      |  G      |</span>
<span class="go">--+---------+---------+---------+---------+--</span>
<span class="go">T | TTT F   | TCT S   | TAT Y   | TGT C   | T</span>
<span class="go">T | TTC F   | TCC S   | TAC Y   | TGC C   | C</span>
<span class="go">T | TTA L   | TCA S   | TAA Stop| TGA W   | A</span>
<span class="go">T | TTG L   | TCG S   | TAG Stop| TGG W   | G</span>
<span class="go">--+---------+---------+---------+---------+--</span>
<span class="go">C | CTT L   | CCT P   | CAT H   | CGT R   | T</span>
<span class="go">C | CTC L   | CCC P   | CAC H   | CGC R   | C</span>
<span class="go">C | CTA L   | CCA P   | CAA Q   | CGA R   | A</span>
<span class="go">C | CTG L   | CCG P   | CAG Q   | CGG R   | G</span>
<span class="go">--+---------+---------+---------+---------+--</span>
<span class="go">A | ATT I(s)| ACT T   | AAT N   | AGT S   | T</span>
<span class="go">A | ATC I(s)| ACC T   | AAC N   | AGC S   | C</span>
<span class="go">A | ATA M(s)| ACA T   | AAA K   | AGA Stop| A</span>
<span class="go">A | ATG M(s)| ACG T   | AAG K   | AGG Stop| G</span>
<span class="go">--+---------+---------+---------+---------+--</span>
<span class="go">G | GTT V   | GCT A   | GAT D   | GGT G   | T</span>
<span class="go">G | GTC V   | GCC A   | GAC D   | GGC G   | C</span>
<span class="go">G | GTA V   | GCA A   | GAA E   | GGA G   | A</span>
<span class="go">G | GTG V(s)| GCG A   | GAG E   | GGG G   | G</span>
<span class="go">--+---------+---------+---------+---------+--</span>
</pre></div>
</div>
<p>你会发现下面的特性很有用，比如当你查找新基因时：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mito_table</span><span class="o">.</span><span class="n">stop_codons</span>
<span class="go">[&#39;TAA&#39;, &#39;TAG&#39;, &#39;AGA&#39;, &#39;AGG&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mito_table</span><span class="o">.</span><span class="n">start_codons</span>
<span class="go">[&#39;ATT&#39;, &#39;ATC&#39;, &#39;ATA&#39;, &#39;ATG&#39;, &#39;GTG&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mito_table</span><span class="o">.</span><span class="n">forward_table</span><span class="p">[</span><span class="s">&quot;ACG&quot;</span><span class="p">]</span>
<span class="go">&#39;T&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="seq">
<h2>3.11  比较Seq对象<a class="headerlink" href="#seq" title="Permalink to this headline">¶</a></h2>
<p>序列之间的比较实际上是一个比较复杂的话题，没有简单的方法来判断两个序列是等同的。
核心的问题是字母的意义是依赖于上下文的。字母 “A” 既可以是DNA、RNA也可以使蛋白质序
列的一部分。 Biopython在 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象中包含了字母表对象，以此尝试获得这些信息。所
以比较两个 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象意味着既要考虑两个序列的字符串 <em>又要</em> 考虑字母表。</p>
<p>举个例子，你可能会觉得 <tt class="docutils literal"><span class="pre">Seq(&quot;ACGT&quot;,</span> <span class="pre">IUPAC.unambiguous_dna)</span></tt> 和
<tt class="docutils literal"><span class="pre">Seq(&quot;ACGT&quot;,</span> <span class="pre">IUPAC.ambiguous_dna)</span></tt> 这两个DNA <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象是一样的，尽管它们确实具
有不同的字母表。根据上下文来判断是很重要的。</p>
<p>下面这种情况更遭：假设你认为 <tt class="docutils literal"><span class="pre">Seq(&quot;ACGT&quot;,</span> <span class="pre">IUPAC.unambiguous_dna)</span></tt> 和
<tt class="docutils literal"><span class="pre">Seq(&quot;ACGT&quot;)</span></tt> （也就是默认的通用字母表）是等同的。那么依照逻辑，
<tt class="docutils literal"><span class="pre">Seq(&quot;ACGT&quot;,</span> <span class="pre">IUPAC.protein)</span></tt> 和 <tt class="docutils literal"><span class="pre">Seq(&quot;ACGT&quot;)</span></tt> 也是等同的。现在从理
论上讲，如果 <em>A</em>=<em>B</em> ， <em>B</em>=<em>C</em> ，那么通过递延性，我们会期望
<em>A</em>=<em>C</em> 。因此遵从逻辑上的一致性我们需要将 <tt class="docutils literal"><span class="pre">Seq(&quot;ACGT&quot;,</span> <span class="pre">IUPAC.unambiguous_dna)</span></tt>
和 <tt class="docutils literal"><span class="pre">Seq(&quot;ACGT&quot;,</span> <span class="pre">IUPAC.protein)</span></tt> 等同起来，虽然大部分人会同意这一递延，
但是这是错误的。这一递延性的问题也会影响使用 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象作为Python字典
的键值。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq1</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;ACGT&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq2</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;ACGT&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
</pre></div>
</div>
<p>那么接下来Biopython会怎么做？等同性测试是Python对象默认要做的测试。经过
检验查看内存中的对象是不是同一个。这是一个非常严格的测试：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seq1</span> <span class="o">==</span> <span class="n">seq2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq1</span> <span class="o">==</span> <span class="n">seq1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>如果你真想这么做，你可以更明确地使用Python中的 <tt class="docutils literal"><span class="pre">id</span></tt> 函数，</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">seq2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>在日常使用中，你的所有序列可能都是同一个字母表，或者至少都是同一类型的序列
（都是DNA、RNA或者都是蛋白质）。你可能想要的只是以字符串的形式比较这些序列，
那么直接这么做：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>作为一个扩展，你可以建立一个Python字典，以 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象作为键值。一般情况下，
将序列作为字符串赋予键值更有用。详见 <a class="reference internal" href="#sec-seq-to-string"><em>3.4</em></a> 部分。</p>
</div>
<div class="section" id="mutableseq">
<span id="sec-mutable-seq"></span><h2>3.12  MutableSeq对象<a class="headerlink" href="#mutableseq" title="Permalink to this headline">¶</a></h2>
<p>就像正常的Python字符串， <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象是 “只读的” ，在Python术语上就是不可变的。
除了想要 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象表现得向一个字符串之外，这是一个很有用的默认，因为在生
物学应用上你往往需要确保你没有改动你的序列数据：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">Seq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">(</span><span class="s">&quot;GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
</pre></div>
</div>
<p>当你尝试编辑序列是你看看会发生什么：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">my_seq</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;G&quot;</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;Seq&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>但是你可以使用 <tt class="docutils literal"><span class="pre">MutableSeq</span></tt> 对象将它转换成可变的序列，然后做任何你想要做的。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span> <span class="o">=</span> <span class="n">my_seq</span><span class="o">.</span><span class="n">tomutable</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span>
<span class="go">MutableSeq(&#39;GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<p>或者你可以直接从字符串建立一个 <tt class="docutils literal"><span class="pre">MutableSeq</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">MutableSeq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span> <span class="o">=</span> <span class="n">MutableSeq</span><span class="p">(</span><span class="s">&quot;GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA&quot;</span><span class="p">,</span> <span class="n">IUPAC</span><span class="o">.</span><span class="n">unambiguous_dna</span><span class="p">)</span>
</pre></div>
</div>
<p>这两种方式都可以将序列对象转换成可变的：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span>
<span class="go">MutableSeq(&#39;GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;C&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span>
<span class="go">MutableSeq(&#39;GCCATCGTAATGGGCCGCTGAAAGGGTGCCCGA&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span>
<span class="go">MutableSeq(&#39;GCCACGTAATGGGCCGCTGAAAGGGTGCCCGA&#39;, IUPACUnambiguousDNA())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_seq</span>
<span class="go">MutableSeq(&#39;AGCCCGTGGGAAAGTCGCCGGGTAATGCACCG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<dl class="docutils">
<dt>请注意与 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象不同的是， <tt class="docutils literal"><span class="pre">MutableSeq</span></tt> 对象的各种方法都是实时呈现的，比如</dt>
<dd><tt class="docutils literal"><span class="pre">reverse_complement()</span></tt> 和 <tt class="docutils literal"><span class="pre">reverse()</span></tt> 方法！</dd>
</dl>
<p>Python中可变对象和不可变对象的一个重要的技术差别就是 <tt class="docutils literal"><span class="pre">MutableSeq</span></tt> 对象不可以作为
字典的键值 ，但是Python字符串或者 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象就可以。</p>
<p>一旦你的 <tt class="docutils literal"><span class="pre">MutableSeq</span></tt> 对象编辑完成，很容易将它变回到只读的 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象，你只需：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">new_seq</span> <span class="o">=</span> <span class="n">mutable_seq</span><span class="o">.</span><span class="n">toseq</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_seq</span>
<span class="go">Seq(&#39;AGCCCGTGGGAAAGTCGCCGGGTAATGCACCG&#39;, IUPACUnambiguousDNA())</span>
</pre></div>
</div>
<dl class="docutils">
<dt>就像你从 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象中获取字符串一样，你也可以从 <tt class="docutils literal"><span class="pre">MutableSeq</span></tt> 获得（参见</dt>
<dd><a class="reference internal" href="#sec-seq-to-string"><em>3.4</em></a> 章节）。</dd>
</dl>
</div>
<div class="section" id="unknownseq">
<h2>3.13  UnknownSeq对象<a class="headerlink" href="#unknownseq" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">UnknownSeq</span></tt> 对象是基本的 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象中的一个子类，其目的是一个已知长度的
序列，但序列并不是由实际的字母组成的。在这种情况下，你当然可以将其作为一个
正常的 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象，但是存储由一百万个 “N” 字母组成的字符串会浪费相当大量的内
存，这时你可以只存储一个 “N” 和序列所需的长度（整数）。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">UnknownSeq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk</span> <span class="o">=</span> <span class="n">UnknownSeq</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk</span>
<span class="go">UnknownSeq(20, alphabet = Alphabet(), character = &#39;?&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">unk</span>
<span class="go">????????????????????</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">unk</span><span class="p">)</span>
<span class="go">20</span>
</pre></div>
</div>
<p>当然你也可以指定一个字母，而不仅仅是 “?” 。一般核苷酸序列默认为 “N” ，蛋白质
序列默认为 “X” 。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">UnknownSeq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Alphabet</span> <span class="kn">import</span> <span class="n">IUPAC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk_dna</span> <span class="o">=</span> <span class="n">UnknownSeq</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="n">IUPAC</span><span class="o">.</span><span class="n">ambiguous_dna</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk_dna</span>
<span class="go">UnknownSeq(20, alphabet = IUPACAmbiguousDNA(), character = &#39;N&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">unk_dna</span>
<span class="go">NNNNNNNNNNNNNNNNNNNN</span>
</pre></div>
</div>
<p>你可以使用所有常规的 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象，记住这些可以节省内存的 <tt class="docutils literal"><span class="pre">UnknownSeq</span></tt> 对象，
如你所希望的那样在恰当的地方使用。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">unk_dna</span>
<span class="go">UnknownSeq(20, alphabet = IUPACAmbiguousDNA(), character = &#39;N&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk_dna</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="go">UnknownSeq(20, alphabet = IUPACAmbiguousDNA(), character = &#39;N&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk_dna</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">()</span>
<span class="go">UnknownSeq(20, alphabet = IUPACAmbiguousDNA(), character = &#39;N&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk_dna</span><span class="o">.</span><span class="n">transcribe</span><span class="p">()</span>
<span class="go">UnknownSeq(20, alphabet = IUPACAmbiguousRNA(), character = &#39;N&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk_protein</span> <span class="o">=</span> <span class="n">unk_dna</span><span class="o">.</span><span class="n">translate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk_protein</span>
<span class="go">UnknownSeq(6, alphabet = ProteinAlphabet(), character = &#39;X&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">unk_protein</span>
<span class="go">XXXXXX</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">unk_protein</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<p>你也许能够在自己的代码中找到 <tt class="docutils literal"><span class="pre">UnknownSeq</span></tt> 对象的应用，但你更可能首先在由
<tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> 创建的 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> 对象中遇到 <tt class="docutils literal"><span class="pre">UnknownSeq</span></tt> 对象（参见第
<a class="reference internal" href="chr05.html#chapter-bio-seqio"><em>5</em></a> 章）。一些序列格式的文件不总是由实际的序列组成，
像GenBank和EMBL文件就可能包含各种特征的列表，而序列部分仅展示contig信息。
又或者在测序工作中的QUAL文件仅包含质量分数，而 <em>从未</em> 包含序列，取而代之的
和QUAL文件同时生成的FASTA格式文件 <em>确实</em> 是由序列构成。</p>
</div>
<div class="section" id="sec-seq-module-functions">
<span id="id12"></span><h2>3.14  直接使用字符串<a class="headerlink" href="#sec-seq-module-functions" title="Permalink to this headline">¶</a></h2>
<p>在这一章的结尾，对于那些 <em>真的</em> 不想使用序列对象的人（或者那些更喜欢面向
对象的函数式编程风格的人）， <tt class="docutils literal"><span class="pre">Bio.Seq</span></tt> 的模块级别的函数可以接受普通的
Python字符串，比如 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象（包括 <tt class="docutils literal"><span class="pre">UnknownSeq</span></tt> 对象）或者 <tt class="docutils literal"><span class="pre">MutableSeq</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.Seq</span> <span class="kn">import</span> <span class="n">reverse_complement</span><span class="p">,</span> <span class="n">transcribe</span><span class="p">,</span> <span class="n">back_transcribe</span><span class="p">,</span> <span class="n">translate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_string</span> <span class="o">=</span> <span class="s">&quot;GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGTTAG&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reverse_complement</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span>
<span class="go">&#39;CTAACCAGCAGCACGACCACCCTTCCAACGACCCATAACAGC&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transcribe</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span>
<span class="go">&#39;GCUGUUAUGGGUCGUUGGAAGGGUGGUCGUGCUGCUGGUUAG&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">back_transcribe</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span>
<span class="go">&#39;GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGTTAG&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">translate</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span>
<span class="go">&#39;AVMGRWKGGRAAG*&#39;</span>
</pre></div>
</div>
<p>尽管如此，我们鼓励你使用默认的 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">第3章     生物序列对象</a><ul>
<li><a class="reference internal" href="#id2">3.1  序列和字母表</a></li>
<li><a class="reference internal" href="#id3">3.2  序列表现的像字符串一样</a></li>
<li><a class="reference internal" href="#id4">3.3  切取序列</a></li>
<li><a class="reference internal" href="#sec-seq-to-string">3.4  将序列对象转换成字符串</a></li>
<li><a class="reference internal" href="#id6">3.5  连接或添加序列</a></li>
<li><a class="reference internal" href="#id7">3.6  改变大小写</a></li>
<li><a class="reference internal" href="#sec-seq-reverse-complement">3.7  核苷酸序列和（反向）互补序列</a></li>
<li><a class="reference internal" href="#id9">3.8  转录</a></li>
<li><a class="reference internal" href="#sec-translation">3.9  翻译</a></li>
<li><a class="reference internal" href="#id11">3.10  翻译表</a></li>
<li><a class="reference internal" href="#seq">3.11  比较Seq对象</a></li>
<li><a class="reference internal" href="#mutableseq">3.12  MutableSeq对象</a></li>
<li><a class="reference internal" href="#unknownseq">3.13  UnknownSeq对象</a></li>
<li><a class="reference internal" href="#sec-seq-module-functions">3.14  直接使用字符串</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chr02.html"
                        title="previous chapter">第2章 快速开始 —— 你能用Biopython做什么？</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chr04.html"
                        title="next chapter">第4章  序列注释对象</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chr03.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chr04.html" title="第4章 序列注释对象"
             >next</a> |</li>
        <li class="right" >
          <a href="chr02.html" title="第2章 快速开始 —— 你能用Biopython做什么？"
             >previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, biopythoners.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>