<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第20章 高级 &mdash; biopython_cn 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="biopython_cn 0.1 documentation" href="index.html" />
    <link rel="next" title="第21章 为Biopython做贡献" href="chr21.html" />
    <link rel="prev" title="第19章 Biopython测试框架" href="chr19.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chr21.html" title="第21章 为Biopython做贡献"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chr19.html" title="第19章 Biopython测试框架"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-advanced">
<span id="id1"></span><h1>第20章 高级<a class="headerlink" href="#chapter-advanced" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>20.1  解析器的设计<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>过去很多Biopython解析器都是根据面向事件设计出来的，包括Scanner和Consumer。</p>
<p>Scanners是将输入的数据源进行逐行分析，只要识别出数据中的信息就会发送一个事件。
例如，如果数据中包含物种名信息，Scanner只要读到某行包含名称信息时就会产生一个 <tt class="docutils literal"><span class="pre">organism_name</span></tt> 事件。</p>
<p>Consumers是用来接收Scanners所发出事件的对象。
接着上面的例子，当Consumer收到了 <tt class="docutils literal"><span class="pre">organism_name</span></tt> 事件，在当前应用程序中无论以何种方式都会运行。</p>
<p>这是一个非常灵活的构架，如果你想要将一个文件解析成多种其他格式的，这将会很有优势。
例如， <tt class="docutils literal"><span class="pre">Bio.GenBank</span></tt> 模块可以运用这种方式构建 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> 或者其他独特的文件格式记录对象。</p>
<p>最近，很多添加了 <tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> 和 <tt class="docutils literal"><span class="pre">Bio.AlignIO</span></tt> 的解析器使用了一种更为简单的方法，
但是只能产生单一形式的文件格式（分别是 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> and <tt class="docutils literal"><span class="pre">MultipleSeqAlignment</span></tt> ）。
在某些情况，<tt class="docutils literal"><span class="pre">Bio.SeqIO</span></tt> 解析器实际上包含了另一种Biopython解析器 - 例如， <tt class="docutils literal"><span class="pre">Bio.SwissProt</span></tt> 解析器产生了特定的SwissProt格式对象，又转换成了 <tt class="docutils literal"><span class="pre">SeqRecord</span></tt> 格式对象。</p>
</div>
<div class="section" id="id3">
<h2>20.2  替换矩阵<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="subsmat">
<h3>20.2.1  SubsMat<a class="headerlink" href="#subsmat" title="Permalink to this headline">¶</a></h3>
<p>这个模块提供了一个类和一些固定的方法来产生替换矩阵，类似于BLOSUM或者PAM矩阵，但是是基于用户提供的数据。
此外，你还可以从已建立的替换矩阵集合MatrixInfo.py中选择一个矩阵。
<tt class="docutils literal"><span class="pre">SeqMat</span></tt> 类来自于一个字典（dictionary）:</p>
<div class="code python highlight-python"><pre>class SeqMat(dict)</pre>
</div>
<p>这个字典的格式是 <tt class="docutils literal"><span class="pre">{(i1,j1):n1,</span> <span class="pre">(i1,j2):n2,...,(ik,jk):nk}</span></tt> ， i和j是字母集，而n是一个值。</p>
<ol class="arabic">
<li><p class="first">属性</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">self.alphabet</span></tt>: Bio.Alphabet中定义的一个类</li>
<li><tt class="docutils literal"><span class="pre">self.ab_list</span></tt>: 排列好的字母列表。主要是内部需求。</li>
</ol>
</li>
<li><p class="first">方法</p>
<ol class="arabic">
<li><div class="code python first highlight-python"><pre>__init__(self,data=None,alphabet=None, mat_name='', build_later=0):</pre>
</div>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">data</span></tt>: 可以是一个字典，也可以是另一个SeqMat实例。</li>
<li><tt class="docutils literal"><span class="pre">alphabet</span></tt>: 一个Bio.Alphabet的实例。如果没有提供，将从数据构建一个alphabet。</li>
<li><tt class="docutils literal"><span class="pre">mat_name</span></tt>: 矩阵名，例如  <tt class="docutils literal"><span class="pre">BLOSUM62</span></tt> 或者 <tt class="docutils literal"><span class="pre">PAM250</span></tt></li>
<li><tt class="docutils literal"><span class="pre">build_later</span></tt>: 默认值为false。如果为true，用户应该只提供alphabet和空字典。如果想要之后再构建矩阵，这样会跳过alphabet大小和矩阵大小的检查。</li>
</ol>
</li>
<li><div class="code python first highlight-python"><div class="highlight"><pre><span class="n">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">obs_freq_mat</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">obs_freq_mat</span></tt>: 一个观测频率矩阵。基于“obs_freq_mat”的频率返回矩阵的熵值。矩阵实例须为LO或者SUBS。</li>
</ol>
</li>
<li><div class="code python first highlight-python"><div class="highlight"><pre><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>计算矩阵的字母表中每个字母值的总和，返回值是字典的形式 <tt class="docutils literal"><span class="pre">{i1:</span> <span class="pre">s1,</span> <span class="pre">i2:</span> <span class="pre">s2,...,in:sn}</span></tt>, 其中:</p>
<ul class="simple">
<li>i: 一个字母;</li>
<li>s: 半矩阵中某个字母值的总和;</li>
<li>n: alphabet中字母的个数。</li>
</ul>
</li>
<li><div class="code python first highlight-python"><div class="highlight"><pre><span class="n">print_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%4d</span><span class="s">&quot;</span><span class="p">,</span><span class="n">bottomformat</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%4s</span><span class="s">&quot;</span><span class="p">,</span><span class="n">alphabet</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>将矩阵打印到文件句柄f。 <tt class="docutils literal"><span class="pre">format</span></tt> 是矩阵值的格式； <tt class="docutils literal"><span class="pre">bottomformat</span></tt> 是底部行（矩阵字母）的格式。下面是一个3字母矩阵的例子：</p>
<div class="code python highlight-python"><pre>A 23
B 12 34
C 7  22  27
  A   B   C</pre>
</div>
<p><tt class="docutils literal"><span class="pre">alphabet</span></tt> 可选参数是alphabet中所有字符的一个字符串。如果用户提供了数据，则轴上字母的顺序是根据字符串中的顺序，而不是字母表的顺序。</p>
</li>
</ol>
</li>
<li><p class="first">用法</p>
<p>安排下面这部分是因为大多数读者希望知道如何产生一个对数机率矩阵（log-odds matrix）。
当然，也可以生成和研究过渡矩阵（log-odds matrix）。
但是大部分的人只是想要一个对数机率矩阵，仅此而已。</p>
<ol class="arabic">
<li><p class="first">产生一个可接受的替代矩阵</p>
<p>首先，你应该从数据中产生出一个可接受替代矩阵（accepted replacement matrix，ARM）。
ARM中的数值是根据你的数据中替换的个数决定的。数据可以是一对或者多对的序列比对结果。
例如，丙氨酸被半胱氨酸替换了10次，而半胱氨酸被丙氨酸替换了12次，其相对应的ARM为：</p>
<div class="code python highlight-python"><pre>('A','C'): 10, ('C','A'): 12</pre>
</div>
<p>由于顺序并不重要，用户也可以只用一个输入:</p>
<div class="code python highlight-python"><pre>('A','C'): 22</pre>
</div>
<p>一个SeqMat实例的初始化可以用全矩阵（第一种计数方法：10,12），也可以用半矩阵（后一种方法，22）。
一个蛋白字母全矩阵的大小应该是20x20 = 400。而一个这样的半矩阵大小是20x20/2 + 20/2 = 210。
这是因为相同字母的输入并没有改变（矩阵的对角线）。如果一个大小为N的alphabet：</p>
<ol class="arabic simple">
<li>全矩阵大小: N*N</li>
<li>半矩阵大小: N(N+1)/2</li>
</ol>
<p>如果传递的是全矩阵，SeqMat的构造函数会自动产生半矩阵。
如果传递的是半矩阵，则键的字母将按照字母表顺序排列(&#8216;A&#8217;,&#8217;C&#8217;)，而不是(&#8216;C&#8217;,&#8217;A&#8217;)。</p>
<p>讲到这里，如果你想知道的仅仅只是怎样产生一个对数机率矩阵的话，请直接看用法示例那个章节。对于想要更加深入地知道核苷酸/氨基酸频率数据的读者，接下来要讲的是内部函数的细节。</p>
</li>
<li><p class="first">生成观测频率矩阵(observed frequency matrix，OFM)</p>
<p>用法:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">OFM</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_build_obs_freq_mat</span><span class="p">(</span><span class="n">ARM</span><span class="p">)</span>
</pre></div>
</div>
<p>OFM是由ARM产生的，只是将替换的个数换成了替换频率。</p>
</li>
<li><p class="first">生成期望频率矩阵(expected frequency matrix，EFM)</p>
<p>用法:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">EFM</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_build_exp_freq_mat</span><span class="p">(</span><span class="n">OFM</span><span class="p">,</span><span class="n">exp_freq_table</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">exp_freq_table</span></tt>: 为一个FreqTable的实例。有关FreqTable更多信息请见第 <a class="reference internal" href="#sec-freq-table"><em>20.2.2</em></a> 节。简单地说，期望频率表表示字母表中每个元素显示的频率。这个表相当于一个字典，字母是键，字母对应的频率是值。总和为1。</li>
</ol>
<p>期望频率表可以（理论上说也应该可以）从OFM得到。所以大多数情况你可以用下面的代码产生 <tt class="docutils literal"><span class="pre">exp_freq_table</span></tt>:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">exp_freq_table</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_exp_freq_table_from_obs_freq</span><span class="p">(</span><span class="n">OFM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EFM</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_build_exp_freq_mat</span><span class="p">(</span><span class="n">OFM</span><span class="p">,</span><span class="n">exp_freq_table</span><span class="p">)</span>
</pre></div>
</div>
<p>如果需要，你也可以使用自己提供的 <tt class="docutils literal"><span class="pre">exp_freq_table</span></tt> 。</p>
</li>
<li><p class="first">生成替换频率矩阵(substitution frequency matrix，SFM)</p>
<p>用法:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">SFM</span> <span class="o">=</span> <span class="n">SubsMat</span><span class="o">.</span><span class="n">_build_subs_mat</span><span class="p">(</span><span class="n">OFM</span><span class="p">,</span><span class="n">EFM</span><span class="p">)</span>
</pre></div>
</div>
<p>使用观察频率矩阵(OFM)和期望频率矩阵(EFM)，得到相应值的除法结果。</p>
</li>
<li><p class="first">生成对数机率矩阵(log-odds matrix， LOM)</p>
<p>用法:</p>
<div class="code python highlight-python"><pre>LOM=SubsMat._build_log_odds_mat(SFM[,logbase=10,factor=10.0,round_digit=1])</pre>
</div>
<ol class="arabic simple">
<li>使用替换频率矩阵(SFM)。</li>
<li><tt class="docutils literal"><span class="pre">logbase</span></tt>: 用来产生对数机率值的对数的底。</li>
<li><tt class="docutils literal"><span class="pre">factor</span></tt>: 对数机率值的乘数因子。
每个数通过log(LOM[key])*factor产生，如果需要，还可以四舍五入到 <tt class="docutils literal"><span class="pre">round_digit</span></tt> 指定的小数点位数。</li>
</ol>
</li>
</ol>
</li>
<li><p class="first">用法示例</p>
<p>因为大部分人都想用最简单的方法产生对数机率矩阵（LOM），SubsMat提供了一个可以完成所有需求的函数：</p>
<div class="code python highlight-python"><pre>make_log_odds_matrix(acc_rep_mat,exp_freq_table=None,logbase=10,
                      factor=10.0,round_digit=0):</pre>
</div>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">acc_rep_mat</span></tt>: 用户提供可接受替代矩阵（ARM）</li>
<li><tt class="docutils literal"><span class="pre">exp_freq_table</span></tt>: 期望频率表。如果用户没有提供，就从 <tt class="docutils literal"><span class="pre">acc_rep_mat</span></tt> 产生。</li>
<li><tt class="docutils literal"><span class="pre">logbase</span></tt>: LOM的对数的底。默认为10。</li>
<li><tt class="docutils literal"><span class="pre">round_digit</span></tt>: 四舍五入的小数点位数。默认为0。</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="freqtable">
<span id="sec-freq-table"></span><h3>20.2.2  FreqTable<a class="headerlink" href="#freqtable" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">FreqTable</span><span class="o">.</span><span class="n">FreqTable</span><span class="p">(</span><span class="n">UserDict</span><span class="o">.</span><span class="n">UserDict</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic">
<li><p class="first">属性:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">alphabet</span></tt>: 一个Bio.Alphabet实例。</li>
<li><tt class="docutils literal"><span class="pre">data</span></tt>: 频率字典</li>
<li><tt class="docutils literal"><span class="pre">count</span></tt>: 计数字典(如果有计数的话)。</li>
</ol>
</li>
<li><p class="first">功能:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">read_count(f)</span></tt>: 从f读入一个计数文件。然后将其转换成频率。</li>
<li><tt class="docutils literal"><span class="pre">read_freq(f)</span></tt>: 从f读入一个频率数据文件。当然，我们不用计数，我们感兴趣的是字母频率。</li>
</ol>
</li>
<li><p class="first">用法示例: 文件中有残基的个数，用空格分格，形式如下（以3个字母为例）：</p>
<div class="code python highlight-python"><pre>A   35
B   65
C   100</pre>
</div>
<p>用 <tt class="docutils literal"><span class="pre">FreqTable.read_count(file_handle)</span></tt> 函数读入。</p>
<p>一个等价的频率文件:</p>
<div class="code python highlight-python"><pre>A  0.175
B  0.325
C  0.5</pre>
</div>
<p>反之，残基频率或者计数也可以作为字典输入。
一个计数字典的例子（3个字母）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">:</span> <span class="mi">65</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">}</span>
</pre></div>
</div>
<p>这也意味着&#8217;C&#8217;的频率是0.5，&#8217;B&#8217;的频率是0.325，&#8217;A&#8217;的频率是0.175。A、B、C的总和为200。</p>
<p>一个相同数据的频率字典如下：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mf">0.175</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">:</span> <span class="mf">0.325</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">}</span>
</pre></div>
</div>
<p>总和为1。</p>
<p>当传入一个字典数据作为参数，应该指出这是一个计数还是频率的字典。因此FreqTable类的构造函数需要两个参数：字典本身和FreqTable.COUNT或者FreqTable.FREQ，分别代表计数或者频率。</p>
<p>读入期望的计数，readCount会产生频率。下面的任意一个都可以用来产生频率表（ftab）：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">SubsMat</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FreqTable</span><span class="o">.</span><span class="n">FreqTable</span><span class="p">(</span><span class="n">my_frequency_dictionary</span><span class="p">,</span><span class="n">FreqTable</span><span class="o">.</span><span class="n">FREQ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FreqTable</span><span class="o">.</span><span class="n">FreqTable</span><span class="p">(</span><span class="n">my_count_dictionary</span><span class="p">,</span><span class="n">FreqTable</span><span class="o">.</span><span class="n">COUNT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FreqTable</span><span class="o">.</span><span class="n">read_count</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;myCountFile&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ftab</span> <span class="o">=</span> <span class="n">FreqTable</span><span class="o">.</span><span class="n">read_frequency</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;myFrequencyFile&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ol>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">第20章 高级</a><ul>
<li><a class="reference internal" href="#id2">20.1  解析器的设计</a></li>
<li><a class="reference internal" href="#id3">20.2  替换矩阵</a><ul>
<li><a class="reference internal" href="#subsmat">20.2.1  SubsMat</a></li>
<li><a class="reference internal" href="#freqtable">20.2.2  FreqTable</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chr19.html"
                        title="previous chapter">第19章 Biopython测试框架</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chr21.html"
                        title="next chapter">第21章 为Biopython做贡献</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chr20.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chr21.html" title="第21章 为Biopython做贡献"
             >next</a> |</li>
        <li class="right" >
          <a href="chr19.html" title="第19章 Biopython测试框架"
             >previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, biopythoners.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>