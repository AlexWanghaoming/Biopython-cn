<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第11章 走向3D：PDB模块 &mdash; biopython_cn 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="biopython_cn 0.1 documentation" href="index.html" />
    <link rel="next" title="第12章 Bio.PopGen：群体遗传学" href="chr12.html" />
    <link rel="prev" title="第10章 Swiss-Prot和ExPASy" href="chr10.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chr12.html" title="第12章 Bio.PopGen：群体遗传学"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chr10.html" title="第10章 Swiss-Prot和ExPASy"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="d-pdb">
<h1>第11章  走向3D：PDB模块<a class="headerlink" href="#d-pdb" title="Permalink to this headline">¶</a></h1>
<p>Bio.PDB是Biopython中处理生物大分子晶体结构的模块。除了别的类之外，Bio.PDB包含PDBParser类，此类能够产生一个Structure对象，以一种较方便的方式获取文件中的原子数据。只是在处理PDB文件头所包含的信息时，该类有一定的局限性。</p>
<div class="section" id="id1">
<h2>11.1  晶体结构文件的读与写<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pdb">
<h3>11.1.1  读取PDB文件<a class="headerlink" href="#pdb" title="Permalink to this headline">¶</a></h3>
<p>首先，我们创建一个 <tt class="docutils literal"><span class="pre">PDBParser</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBParser</span> <span class="kn">import</span> <span class="n">PDBParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">(</span><span class="n">PERMISSIVE</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">PERMISSIV</span></tt> 标签表示一些与PDB文件相关的问题（见 <a class="reference external" href="#problem%20structures">11.7.1</a> ）会被忽略（注意某些原子和/或残基会丢失）。如果没有这个标签，则会在解析器运行期间有问题被检测到的时候生成一个 <tt class="docutils literal"><span class="pre">PDBConstructionException</span></tt> 标签。</p>
<p>接着通过 <tt class="docutils literal"><span class="pre">PDBParser</span></tt> 解析PDB文件，就产生了Structure对象（在此例子中，PDB文件为&#8217;pdb1fat.ent&#8217;，&#8216;1fat&#8217;是用户定义的结构名称）:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">structure_id</span> <span class="o">=</span> <span class="s">&quot;1fat&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;pdb1fat.ent&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">structure_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>你可以从PDBParser对象中用 <tt class="docutils literal"><span class="pre">get_header</span></tt> 和 <tt class="docutils literal"><span class="pre">get_trailer</span></tt> 方法来提取PDB文件中的文件头和文件尾（简单的字符串列表）。然而许多PDB文件头包含不完整或错误的信息。许多错误在等价的mmCIF格式文件中得到修正。* 因此，如果你对文件头信息感兴趣，可以用下面即将讲到的 <tt class="docutils literal"><span class="pre">MMCIF2Dict</span></tt> 来提取信息，而不用处理PDB文件文件头。*</p>
<p>现在澄清了，让我们回到解析PDB文件头这件事上。结构对象有个属性叫 <tt class="docutils literal"><span class="pre">header</span></tt> ，这是一个将头记录映射到其相应值的Python字典。</p>
<p>例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">resolution</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;resolution&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keywords</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;keywords&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>在这个字典中可用的关键字有 <tt class="docutils literal"><span class="pre">name</span></tt> 、 <tt class="docutils literal"><span class="pre">head</span></tt> 、 <tt class="docutils literal"><span class="pre">deposition_date</span></tt> 、 <tt class="docutils literal"><span class="pre">release_date</span></tt> 、 <tt class="docutils literal"><span class="pre">structure_method</span></tt> 、 <tt class="docutils literal"><span class="pre">resolution</span></tt> 、 <tt class="docutils literal"><span class="pre">structure_reference</span></tt> （映射到一个参考文献列表）、 <tt class="docutils literal"><span class="pre">journal_reference</span></tt> 、 <tt class="docutils literal"><span class="pre">author</span></tt> 、和 <tt class="docutils literal"><span class="pre">compound</span></tt> （映射到一个字典，其中包含结晶化合物的各种信息）。</p>
<p>没有创建 <tt class="docutils literal"><span class="pre">Structure</span></tt> 对象的时候，也可以创建这个字典，比如直接从PDB文件创建:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">header_dict</span> <span class="o">=</span> <span class="n">parse_pdb_header</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="mmcif">
<h3>11.1.2  读取mmCIF文件<a class="headerlink" href="#mmcif" title="Permalink to this headline">¶</a></h3>
<p>与PDB文件的情形类似，先创建一个 <tt class="docutils literal"><span class="pre">MMCIFParser</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.MMCIFParser</span> <span class="kn">import</span> <span class="n">MMCIFParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">MMCIFParser</span><span class="p">()</span>
</pre></div>
</div>
<p>然后用这个解析器从mmCIF文件创建一个结构对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s">&#39;1fat&#39;</span><span class="p">,</span> <span class="s">&#39;1fat.cif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>为了尽量少访问mmCIF文件，可以用 <tt class="docutils literal"><span class="pre">MMCIF2Dict</span></tt> 类创建一个Python字典来将所有mmCIF文件中各种标签映射到其对应的值上。若有多个值（像 <tt class="docutils literal"><span class="pre">_atom_site.Cartn_y</span></tt> 标签，储存的是所有原子的*y*坐标值），则这个标签映射到一个值列表。从mmCIF文件创建字典如下：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.MMCIF2Dict</span> <span class="kn">import</span> <span class="n">MMCIF2Dict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mmcif_dict</span> <span class="o">=</span> <span class="n">MMCIF2Dict</span><span class="p">(</span><span class="s">&#39;1FAT.cif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>例：从mmCIF文件获取溶剂含量:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">mmcif_dict</span><span class="p">[</span><span class="s">&#39;_exptl_crystal.density_percent_sol&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>例：获取包含所有原子*y*坐标的列表:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y_list</span> <span class="o">=</span> <span class="n">mmcif_dict</span><span class="p">[</span><span class="s">&#39;_atom_site.Cartn_y&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="pdb-xml">
<h3>11.1.3  读取PDB XML格式的文件<a class="headerlink" href="#pdb-xml" title="Permalink to this headline">¶</a></h3>
<p>这个功能暂时还不支持，不过我们确实计划在未来支持这个功能（这项任务并不大）。如果你需要的话联系Biopython开发人员（ <a class="reference external" href="mailto:biopython-dev&#37;&#52;&#48;biopython&#46;org">biopython-dev<span>&#64;</span>biopython<span>&#46;</span>org</a> ）。</p>
</div>
<div class="section" id="id2">
<h3>11.1.4  写PDB文件<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>可以用PDBIO类实现。当然也可很方便地输出一个结构的特定部分。</p>
<p>例子：保存一个结构</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">PDBIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;out.pdb&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你想写出结构的一部分，可以用 <cite>Select</cite> 类（也在 <tt class="docutils literal"><span class="pre">PDBIO</span></tt> 中）来实现。 <cite>Select</cite> 有如下四种方法：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">accept_model(model)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">accept_chain(chain)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">accept_residue(residue)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">accept_atom(atom)</span></tt></li>
</ul>
<p>在默认情况下，每种方法的返回值都为1（表示model/chain/residue/atom被包含在输出结果中）。通过子类化 <tt class="docutils literal"><span class="pre">Select</span></tt> 和返回值0，你可以从输出中排除model、chain等。也许麻烦，但很强大。接下来的代码将只输出甘氨酸残基：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">GlySelect</span><span class="p">(</span><span class="n">Select</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">accept_residue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residue</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="o">==</span><span class="s">&#39;GLY&#39;</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="bp">True</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="bp">False</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">PDBIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;gly_only.pdb&#39;</span><span class="p">,</span> <span class="n">GlySelect</span><span class="p">())</span>
</pre></div>
</div>
<p>如果这部分对你来说太复杂，那么 <tt class="docutils literal"><span class="pre">Dice</span></tt> 模块有一个很方便的 <tt class="docutils literal"><span class="pre">extract</span></tt> 函数，它可以输出一条链中起始和终止氨基酸残基之间的所有氨基酸残基。</p>
</div>
</div>
<div class="section" id="id3">
<h2>11.2  结构的表示<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>一个 <tt class="docutils literal"><span class="pre">Structure</span></tt> 对象的整体布局遵循称为SMCRA（Structure/Model/Chain/Residue/Atom，结构/模型/链/残基/原子）的体系架构：</p>
<ul class="simple">
<li>结构由模型组成</li>
<li>模型由多条链组成</li>
<li>链由残基组成</li>
<li>多个原子构成残基</li>
</ul>
<p>这是很多结构生物学家/生物信息学家看待结构的方法，也是处理结构的一种简单而有效的方法。在需要的时候加上额外的材料。一个 <tt class="docutils literal"><span class="pre">Structure</span></tt> 对象的UML图（暂时忘掉 <tt class="docutils literal"><span class="pre">Disordered</span></tt> 吧）如下图所示 <a class="reference external" href="#fig:smcra">11.1</a> 。这样的数据结构不一定最适用于表示一个结构的生物大分子内容，但要很好地解释一个描述结构的文件中所呈现的数据（最典型的如PDB或MMCIF文件），这样的数据结构就是必要的了。如果这种层次结构不能表示一个结构文件的内容，那么可以相当确定是这个文件有错误或至少描述结构不够明确。一旦不能生成SMCRA数据结构，就有理由怀疑出了故障。因此，解析PDB文件可用于检测可能的故障。我们将在 <a class="reference external" href="#problem%20structures">11.7.1</a> 小节给出关于这一点的一些例子。</p>
<hr class="docutils" />
<p><img alt="image3" src="_images/smcra.png" /></p>
<p>图11.1：用来表示大分子结构的 <tt class="docutils literal"><span class="pre">Structure</span></tt> 类的SMCRA体系的UML图。带方块的实线表示集合，带箭头的实线表示引用，带三角形的实线表示继承，带三角形的虚线表示接口实现。</p>
<hr class="docutils" />
<p>结构，模型，链，残基都是实体基类的子类。原子类仅仅（部分）实现了实体接口（因为原子类没有子类）。</p>
<p>对于每个实体子类，你可以用该子类的一个唯一标识符作为键来提取子类（比如，可以用原子名称作为键从残基对象中提取一个原子对象；用链的标识符作为键从域对象中提取链）。</p>
<p>紊乱原子和残基用DisorderedAtom和DisorderedResidue类来表示，二者都是DisorderedEntityWrapper基类的子类。它们隐藏了紊乱的复杂性，表现得与原子和残基对象无二。</p>
<p>一般地，一个实体子类（即原子，残基，链，模型）能通过标识符作为键来从父类（分别为残基，链，模型，结构）中提取。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">child_entity</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span>
</pre></div>
</div>
<p>你可以从一个父实体对象获得所有子实体的列表。需要注意的是，这个列表以一种特定的方式排列（例如根据在模型对象中链对象的链标识符来排序）。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">child_list</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="o">.</span><span class="n">get_list</span><span class="p">()</span>
</pre></div>
</div>
<p>你也可以从子类得到父类：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parent_entity</span> <span class="o">=</span> <span class="n">child_entity</span><span class="o">.</span><span class="n">get_parent</span><span class="p">()</span>
</pre></div>
</div>
<p>在SMCRA的所有层次水平，你还可以提取一个 <em>完整id</em> 。完整id是包含所有从顶层对象（结构）到当前对象的id的一个元组。一个残基对象的完整id可以这么得到：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">full_id</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_full_id</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">full_id</span>
<span class="go">(&quot;1abc&quot;, 0, &quot;A&quot;, (&quot;&quot;, 10, &quot;A&quot;))</span>
</pre></div>
</div>
<p>这对应于：</p>
<ul class="simple">
<li>id为&#8221;1abc&#8221;的结构</li>
<li>id为0的模型</li>
<li>id为&#8221;A&#8221;的链</li>
<li>id为(&#8221; &#8221;, 10, &#8220;A&#8221;)的残基</li>
</ul>
<p>这个残基id表示该残基不是异质残基（也不是水分子），因为其异质值为空；而序列标识符为10，插入码为&#8221;A&#8221;。</p>
<p>要得到实体的id，用 <tt class="docutils literal"><span class="pre">get_id</span></tt> 方法即可：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">entity</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
</pre></div>
</div>
<p>可以用 <tt class="docutils literal"><span class="pre">has_id</span></tt> 方法来检查这个实体是否有子类具有给定id：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">entity</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="n">entity_id</span><span class="p">)</span>
</pre></div>
</div>
<p>实体的长度等于其子类的个数：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nr_children</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
</pre></div>
</div>
<p>对于从父实体得到的子实体，可以删除，重命名，添加等等，但这并不包含任何完整性检查（比如，有可能添加两个相同id的残基到同一条链上）。这就真的需要包含完整性检查的装饰类（Decorator）来完成了，但是如果你想使用原始接口的话可以查看源代码（Entity.py）。</p>
<div class="section" id="id4">
<h3>11.2.1  结构<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>结构对象是层次中的最高层。其id是用户指定的一个字符串。结构包含一系列子模型。大部分晶体结构（但不是全部）含有一个单一模型，但是NMR结构通常由若干模型构成。晶体结构中大部分子的乱序也能导致多个模型。</p>
</div>
<div class="section" id="id5">
<h3>11.2.2  模型<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>结构域对象的id是一个整数，源自该模型在所解析文件中的位置（自动从0开始）。晶体结构通常只有一个模型（id为0），而NMR文件通常含有多个模型。然而许多PDB解析器都假定只有一个结构域， <tt class="docutils literal"><span class="pre">Bio.PDB</span></tt> 中的 <tt class="docutils literal"><span class="pre">Structure</span></tt> 类就设计成能轻松处理含有不止一个模型的PDB文件。</p>
<p>举个例子，从一个结构对象中获取其第一个模型：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">first_model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>模型对象存储着子链的列表。</p>
</div>
<div class="section" id="id6">
<h3>11.2.3  链<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>链对象的id来自PDB/mmCIF文件中的链标识符，是个单字符（通常是一个字母）。模型中的每个链都具有唯一的id。例如，从一个模型对象中取出标识符为“A”的链对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_A</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>链对象储存着残基对象的列表。</p>
</div>
<div class="section" id="id7">
<h3>11.2.4  残基<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>一个残基id是一个三元组：</p>
<ul>
<li><p class="first"><strong>异质域</strong> (hetfield)，即：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'W'</span></tt> 代表水分子</li>
<li><tt class="docutils literal"><span class="pre">'H_'</span></tt> 后面紧跟残基名称，代表其它异质残基（例如 <tt class="docutils literal"><span class="pre">'H_GLC'</span></tt> 表示一个葡萄糖分子）</li>
<li>空值表示标准的氨基酸和核酸</li>
</ul>
<p>采用这种体制的理由在 <a class="reference external" href="#异质%20问题">11.4.1</a> 部分有叙述。</p>
</li>
<li><p class="first"><strong>序列标识符</strong> （resseq），一个描述该残基在链上的位置的整数（如100）；</p>
</li>
<li><p class="first"><strong>插入码</strong> （icode），一个字符串，如“A”。插入码有时用来保存某种特定的、想要的残基编号体制。一个Ser 80的插入突变（比如在Thr 80和Asn 81残基间插入）可能具有如下序列标识符和插入码：Thr 80 A, Ser 80 B, Asn 81。这样一来，残基编号体制保持与野生型结构一致。</p>
</li>
</ul>
<p>因此，上述的葡萄酸残基id就是 <tt class="docutils literal"><span class="pre">(’H_GLC’,</span> <span class="pre">100,</span> <span class="pre">’A’)</span></tt> 。如果异质标签和插入码为空，那么可以只使用序列标识符：</p>
<div class="code python highlight-python"><pre># Full id
&gt;&gt;&gt; residue=chain[(' ', 100, ' ')]
# Shortcut id
&gt;&gt;&gt; residue=chain[100]</pre>
</div>
<p>异质标签的起因是许许多多的PDB文件使用相同的序列标识符表示一个氨基酸和一个异质残基或一个水分子，这会产生一个很明显的问题，如果不使用异质标签的话。</p>
<p>毫不奇怪，一个残基对象存储着一个子原子集，它还包含一个表示残基名称的字符串（如 “ASN”）和残基的片段标识符（这对X-PLOR的用户来说很熟悉，但是在SMCRA数据结构的构建中没用到）。</p>
<p>让我们来看一些例子。插入码为空的Asn 10具有残基id <tt class="docutils literal"><span class="pre">(’</span> <span class="pre">’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></tt> ；Water 10，残基id <tt class="docutils literal"><span class="pre">(’W’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></tt>；一个序列标识符为10的葡萄糖分子（名称为GLC的异质残基），残基id为 <tt class="docutils literal"><span class="pre">(’H_GLC’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></tt> 。在这种情况下，三个残基（具有相同插入码和序列标识符）可以位于同一条链上，因为它们的残基id是不同的。</p>
<p>大多数情况下，hetflag和插入码均为空，如 <tt class="docutils literal"><span class="pre">(’</span> <span class="pre">’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></tt> 。在这些情况下，序列标识符可以用作完整id的快捷方式：</p>
<div class="code python highlight-python"><pre># use full id
&gt;&gt;&gt; res10 = chain[(' ', 10, ' ')]
# use shortcut
&gt;&gt;&gt; res10 = chain[10]</pre>
</div>
<p>一个链对象中每个残基对象都应该具有唯一的id。但是对含紊乱原子的残基，要以一种特殊的方式来处理，详见 <a class="reference external" href="#point%20mutations">11.3.3</a> 。</p>
<p>一个残基对象还有大量其它方法：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">get_resname</span><span class="p">()</span>       <span class="c"># returns the residue name, e.g. &quot;ASN&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">()</span>     <span class="c"># returns 1 if the residue has disordered atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">get_segid</span><span class="p">()</span>         <span class="c"># returns the SEGID, e.g. &quot;CHN1&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>        <span class="c"># test if a residue has a certain atom</span>
</pre></div>
</div>
<p>你可以用 <tt class="docutils literal"><span class="pre">is_aa(residue)</span></tt> 来检验一个残基对象是否为氨基酸。</p>
</div>
<div class="section" id="id8">
<h3>11.2.5  原子<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>原子对象储存着所有与原子有关的数据，它没有子类。原子的id就是它的名称（如，“OG”代表Ser残基的侧链氧原子）。在残基中原子id必需是唯一的。此外，对于紊乱原子会产生异常，见 <a class="reference external" href="#disordered%20atoms">11.3.2</a> 小节的描述。</p>
<p>原子id就是原子名称（如 <tt class="docutils literal"><span class="pre">’CA’</span></tt> ）。在实践中，原子名称是从PDB文件中原子名称去除所有空格而创建的。</p>
<p>但是在PDB文件中，空格可以是原子名称的一部分。通常，钙原子称为 <tt class="docutils literal"><span class="pre">’CA..’</span></tt> 是为了和Cα原子（叫做 <tt class="docutils literal"><span class="pre">’.CA.’</span></tt> ）区分开。在这种情况下，如果去掉空格就会产生问题（如统一个残基中的两个原子都叫做 <tt class="docutils literal"><span class="pre">’CA’</span></tt> ），所以保留空格。</p>
<p>在PDB文件中，一个原子名字由4个字符组成，通常头尾皆为空格。为了方便使用，空格通常可以去掉（在PDB文件中氨基酸的Cα原子标记为“.CA.”，点表示空格）。为了生成原子名称（然后是原子id），空格删掉了，除非会在一个残基中造成名字冲突（如两个原子对象有相同的名称和id）。对于后面这种情况，会尝试让原子名称包含空格。这种情况可能会发生在，比如残基包含名称为“.CA.”和“CA..”的原子，尽管这不怎么可能。</p>
<p>所存储的原子数据包括原子名称，原子坐标（如果有的话还包括标准差），B因子（包括各向异性B因子和可能存在的标准差），altloc标识符和完整的、包括空格的原子名称。较少用到的项如原子序号和原子电荷（有时在PDB文件中规定）也就没有存储。</p>
<p>为了处理原子坐标，可以用 <tt class="docutils literal"><span class="pre">’Atom’</span></tt> 对象的 <tt class="docutils literal"><span class="pre">transform</span></tt> 方法。用 <tt class="docutils literal"><span class="pre">set_coord</span></tt> 方法可以直接设定原子坐标。</p>
<p>一个Atom对象还有如下其它方法：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>       <span class="c"># atom name (spaces stripped, e.g. &quot;CA&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>         <span class="c"># id (equals atom name)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_coord</span><span class="p">()</span>      <span class="c"># atomic coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>     <span class="c"># atomic coordinates as Vector object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_bfactor</span><span class="p">()</span>    <span class="c"># isotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_occupancy</span><span class="p">()</span>  <span class="c"># occupancy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">()</span>     <span class="c"># alternative location specifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_sigatm</span><span class="p">()</span>     <span class="c"># standard deviation of atomic parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_siguij</span><span class="p">()</span>     <span class="c"># standard deviation of anisotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_anisou</span><span class="p">()</span>     <span class="c"># anisotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_fullname</span><span class="p">()</span>   <span class="c"># atom name (with spaces, e.g. &quot;.CA.&quot;)</span>
</pre></div>
</div>
<p>siguij，各向异性B因子和sigatm Numpy阵列可以用来表示原子坐标。</p>
<p><tt class="docutils literal"><span class="pre">get_vector</span></tt> 方法会返回一个代表 <tt class="docutils literal"><span class="pre">Atom</span></tt>  对象坐标的 <tt class="docutils literal"><span class="pre">Vector</span></tt> 对象，可以对原子坐标进行向量运算。 <tt class="docutils literal"><span class="pre">Vector</span></tt> 实现了完整的三维向量运算、矩阵乘法（包括左乘和右乘）和一些高级的、与旋转相关的操作。</p>
<p>举个Bio.PDB的 <tt class="docutils literal"><span class="pre">Vector</span></tt> 模块功能的例子，假设你要查找Gly残基的Cβ原子的位置，如果存在的话。将Gly残基的N原子沿Cα-C化学键旋转-120度，能大致将其放在一个真正的Cβ原子的位置上。怎么做呢？就是下面这样使用 <tt class="docutils literal"><span class="pre">Vector</span></tt> 模块中的``rotaxis`` 方法（能用来构造一个绕特定坐标轴的旋转）：</p>
<div class="code python highlight-python"><pre># get atom coordinates as vectors
&gt;&gt;&gt; n = residue['N'].get_vector()
&gt;&gt;&gt; c = residue['C'].get_vector()
&gt;&gt;&gt; ca = residue['CA'].get_vector()
# center at origin
&gt;&gt;&gt; n = n - ca
&gt;&gt;&gt; c = c - ca
# find rotation matrix that rotates n
# -120 degrees along the ca-c vector
&gt;&gt;&gt; rot = rotaxis(-pi * 120.0/180.0, c)
# apply rotation to ca-n vector
&gt;&gt;&gt; cb_at_origin = n.left_multiply(rot)
# put on top of ca atom
&gt;&gt;&gt; cb = cb_at_origin+ca</pre>
</div>
<p>这个例子展示了在原子数据上能进行一些相当不平凡的向量运算，这些运算会很有用。除了所有常用向量运算（叉积（用 <tt class="docutils literal"><span class="pre">*</span></tt><tt class="docutils literal"><span class="pre">*</span></tt> ），点积（用 <tt class="docutils literal"><span class="pre">*</span></tt> ），角度， 取范数等）和上述提到的 <tt class="docutils literal"><span class="pre">rotaxis</span></tt> 函数，<tt class="docutils literal"><span class="pre">Vector</span></tt> 模块还有方法能旋转（ <tt class="docutils literal"><span class="pre">rotmat</span></tt> ）或反射（ <tt class="docutils literal"><span class="pre">refmat</span></tt> ）一个向量到另外一个向量上。</p>
</div>
<div class="section" id="atom-residue-chain-model">
<h3>11.2.6  从结构中提取指定的 <tt class="docutils literal"><span class="pre">Atom/Residue/Chain/Model</span></tt><a class="headerlink" href="#atom-residue-chain-model" title="Permalink to this headline">¶</a></h3>
<p>举些例子如下：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s">&#39;CA&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>还可以用一个快捷方式：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;A&#39;</span><span class="p">][</span><span class="mi">100</span><span class="p">][</span><span class="s">&#39;CA&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id9">
<h2>11.3  紊乱<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>Bio.PDB能够处理紊乱原子和点突变（比如Gly和Ala残基在相同位置上）。</p>
<div class="section" id="id10">
<h3>11.3.1  一般性方法<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>紊乱可以从两个角度来解决：原子和残基的角度。一般来说，我们尝试压缩所有由紊乱引起的复杂性。如果你仅仅想遍历所有Cα原子，那么你不必在意一些具有紊乱侧链的残基。另一方面，应该考虑在数据结构中完整地表示紊乱性。因此，紊乱原子或残基存储在特定的对象中，这些对象表现得就像毫无紊乱。这可以通过表示紊乱原子或残基的子集来完成。至于挑选哪个子集（例如使用Ser残基的哪两个紊乱OG侧链原子位置），由用户来决定。</p>
</div>
<div class="section" id="id11">
<h3>11.3.2  紊乱原子<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>紊乱原子可以用普通的 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象来表示，但是所有表示相同物理原子的 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象都存储在一个 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象中（见图. <a class="reference external" href="#fig:smcra">11.1</a> ）。 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象中每个 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象都能用它的altloc标识符来唯一地索引。 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象将所有未捕获方法的调用发送给选定的Atom对象，缺省对象是代表最高使用率的原子的那个。当然用户可以使用其altloc标识符来更改选定的 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象。以这种方式，原子紊乱就正确地表示出来而没有很多额外的复杂性。换言之，如果你对原子紊乱不感兴趣，你也不会被它困扰。</p>
<p>每个紊乱原子都有一个特征性的altloc标识符。你可以设定：一个 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象表现得像与一个指定的altloc标识符相关的 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c"># select altloc A atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">()</span>
<span class="go">&quot;A&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span> <span class="c"># select altloc B atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">()</span>
<span class="go">&quot;B&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>11.3.3  紊乱残基<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id13">
<h4>普通例子<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>最常见的例子是一个残基包含一个或多个紊乱原子。这显然可以通过用DisorderedAtom对象表示这些紊乱原子来解决，并将DisorderedAtom对象存储在一个Residue对象中，就像正常的Atom对象那样。通过将所有未捕获方法调用发送给其中一个Atom对象（被选定的Atom对象），DisorderedAtom对象表现完全像一个正常的原子对象（事实上这个原子有最高的使用率）。</p>
</div>
<div class="section" id="id14">
<h4>点突变<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>一个特殊的例子就是当紊乱是由点突变导致的时候，也就是说，在晶体结构中出现一条多肽的两或多个点突变。关于这一点，可以在PDB结构1EN2中找到一个例子。</p>
<p>既然这些残基属于不同的残基类型（举例说Ser 60 和Cys 60），那么它们不应该像通常情况一样存储在一个单一 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象中。这种情况下每个残基用一个 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象来表示，两种 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象都保存在一个单一 <tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 对象中（见 图. <a class="reference external" href="#fig:smcra">11.1</a> ）。</p>
<p><tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 对象将所有未捕获方法发送给选定的 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象（默认是所添加的最后一个 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象），因此表现得像一个正常的残基。在 <tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 中每个 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象可通过残基名称来唯一标识。在上述例子中，残基Ser 60在 <tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 对象中的id为“SER”，而残基Cys 60则是“CYS”。用户可以通过这个id选择在 <tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 中的有效 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象。</p>
<p>例子：假设一个链在位置10有一个由Ser和Cys残基构成的点突变。确信这个链的残基10表现为Cys残基。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s">&#39;CYS&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>另外，通过使用 <tt class="docutils literal"><span class="pre">(Disordered)Residue</span></tt> 对象的 <tt class="docutils literal"><span class="pre">get_unpacked_list</span></tt> 方法，你能获得所有 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象的列表（也就是说，所有 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象解包到它们各自的 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象）。</p>
</div>
</div>
</div>
<div class="section" id="id15">
<h2>11.4  异质残基<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id16">
<h3>11.4.1  相关问题<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>关于异质残基的一个很普遍的问题是同一条链中的若干异质和非异质残基有同样的序列标识符（和插入码）。因此，要为每个异质残基生成唯一的id，水分子和其他异质残基应该以不同的方式来对待。</p>
<p>记住Residue残基有一个元组（hetfield, resseq, icode）作为id。hetfield值为空(“ ”)表示为氨基酸和核酸；为一个字符串，则表示水分子和其他异质残基。hetfield的内容将在下面解释。</p>
</div>
<div class="section" id="id17">
<h3>11.4.2  水残基<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>水残基的hetfield字符串由字母“W”构成。所以水分子的一个典型的残基id为(“W”, 1, “ ”)。</p>
</div>
<div class="section" id="id18">
<h3>11.4.3  其他异质残基<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>其他异质残基的hetfield字符以“H_”起始，后接残基名称。一个葡萄糖分子，比如残基名称为“GLC”，则hetfield字符为“H_GLC”；它的残基id可以是(“H_GLC”, 1,
“ ”)。</p>
</div>
</div>
<div class="section" id="structure">
<h2>11.5  浏览Structure对象<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pdb-modelchainresidueatom">
<h3>解析PDB文件，提取一些Model、Chain、Residue和Atom对象<a class="headerlink" href="#pdb-modelchainresidueatom" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBParser</span> <span class="kn">import</span> <span class="n">PDBParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="s">&quot;1fat.pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s">&quot;CA&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>迭代遍历一个结构中的所有原子<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="s">&#39;pdb1fat.ent&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">:</span>
<span class="gp">... </span>                <span class="k">print</span> <span class="n">atom</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>有个快捷方式可以遍历一个结构中所有原子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">atom</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>类似地，遍历一条链中的所有原子，可以这么做：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">atom</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h3>遍历模型中的所有残基<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>或者，如果你想遍历在一条模型中的所有残基：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residues</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_residues</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">residue</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>你也可以用 <tt class="docutils literal"><span class="pre">Selection.unfold_entities</span></tt> 函数来获取一个结构的所有残基：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="s">&#39;R&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>或者获得链上的所有原子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>明显的是， <tt class="docutils literal"><span class="pre">A=atom,</span> <span class="pre">R=residue,</span> <span class="pre">C=chain,</span> <span class="pre">M=model,</span> <span class="pre">S=structure</span></tt> 。你可以用这种标记返回层次中的上层，如从一个 <tt class="docutils literal"><span class="pre">Atoms</span></tt> 列表得到（唯一的） <tt class="docutils literal"><span class="pre">Residue</span></tt> 或 <tt class="docutils literal"><span class="pre">Chain</span></tt> 父类的列表：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residue_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>更多信息详见API文档。</p>
</div>
<div class="section" id="resseq-10-glc">
<h3>从链中提取异质残基（如resseq 10的葡萄糖（GLC）部分）<a class="headerlink" href="#resseq-10-glc" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residue_id</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;H_GLC&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="n">residue_id</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>打印链中所有异质残基<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">residue_id</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>   <span class="n">hetfield</span> <span class="o">=</span> <span class="n">residue_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>   <span class="k">if</span> <span class="n">hetfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s">&quot;H&quot;</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">print</span> <span class="n">residue_id</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="b50ca">
<h3>输出一个结构分子中所有B因子大于50的CA原子的坐标<a class="headerlink" href="#b50ca" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="s">&quot;CA&quot;</span><span class="p">):</span>
<span class="gp">... </span>                <span class="n">ca</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s">&quot;CA&quot;</span><span class="p">]</span>
<span class="gp">... </span>                <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_bfactor</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">50.0</span><span class="p">:</span>
<span class="gp">... </span>                    <span class="k">print</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_coord</span><span class="p">()</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h3>输出所有含紊乱原子的残基<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                <span class="n">resseq</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_id</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>                <span class="n">resname</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_resname</span><span class="p">()</span>
<span class="gp">... </span>                <span class="n">model_id</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>                <span class="n">chain_id</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>                <span class="k">print</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">chain_id</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resseq</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="altloc-a">
<h3>遍历所有紊乱原子，并选取所有具有altloc A的原子（如果有的话）<a class="headerlink" href="#altloc-a" title="Permalink to this headline">¶</a></h3>
<p>这将会保证，SMCRA数据结构会表现得如同只存在altloc A原子一样。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">disordered_has_id</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">):</span>
<span class="gp">... </span>                            <span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h3>从 <tt class="docutils literal"><span class="pre">Structure</span></tt> 对象中提取多肽<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h3>
<p>为了从一个结构中提取多肽，需要用 <tt class="docutils literal"><span class="pre">PolypeptideBuilder</span></tt> 从 <tt class="docutils literal"><span class="pre">Structure</span></tt> 构建一个 <tt class="docutils literal"><span class="pre">Polypeptide</span></tt> 对象的列表，如下所示：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model_nr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polypeptide_list</span> <span class="o">=</span> <span class="n">build_peptides</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">model_nr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">polypeptide</span> <span class="ow">in</span> <span class="n">polypeptide_list</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">polypeptide</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Polypeptide对象正是Residue对象的一个UserList，总是从单结构域（在此例中为模型1）中创建而来。你可以用所得 <tt class="docutils literal"><span class="pre">Polypeptide</span></tt> 对象来获取序列作为 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象，或获得Cα原子的列表。多肽可以通过一个C-N 化学键或一个Cα-Cα化学键距离标准来建立。</p>
<p>例子：</p>
<div class="code python highlight-python"><pre># Using C-N
&gt;&gt;&gt; ppb=PPBuilder()
&gt;&gt;&gt; for pp in ppb.build_peptides(structure):
...     print pp.get_sequence()
...
# Using CA-CA
&gt;&gt;&gt; ppb=CaPPBuilder()
&gt;&gt;&gt; for pp in ppb.build_peptides(structure):
...     print pp.get_sequence()
...</pre>
</div>
<p>需要注意的是，上例中通过 <tt class="docutils literal"><span class="pre">PolypeptideBuilder</span></tt> 只考虑了结构的模型 0。尽管如此，还是可以用 <tt class="docutils literal"><span class="pre">PolypeptideBuilder</span></tt> 从 <tt class="docutils literal"><span class="pre">Model</span></tt> 和 <tt class="docutils literal"><span class="pre">Chain</span></tt> 对象创建 <tt class="docutils literal"><span class="pre">Polypeptide</span></tt> 对象。</p>
</div>
<div class="section" id="id24">
<h3>获取结构的序列<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>要做的第一件事就是从结构中提取所有多肽（如上所述）。然后每条多肽的序列就容易从 <tt class="docutils literal"><span class="pre">Polypeptide</span></tt> 对象获得。该序列表示为一个Biopython <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象，它的字母表由 <tt class="docutils literal"><span class="pre">ProteinAlphabet</span></tt> 对象来定义。</p>
<p>例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">polypeptide</span><span class="o">.</span><span class="n">get_sequence</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">seq</span>
<span class="go">Seq(&#39;SNVVE...&#39;, &lt;class Bio.Alphabet.ProteinAlphabet&gt;)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id25">
<h2>11.6  分析结构<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id26">
<h3>11.6.1  度量距离<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>重载原子的减法运算来返回两个原子之间的距离。</p>
<div class="code python highlight-python"><pre># Get some atoms
&gt;&gt;&gt; ca1 = residue1['CA']
&gt;&gt;&gt; ca2 = residue2['CA']
# Simply subtract the atoms to get their distance
&gt;&gt;&gt; distance = ca1-ca2</pre>
</div>
</div>
<div class="section" id="id27">
<h3>11.6.2  度量角度<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>用原子坐标的向量表示，和 <tt class="docutils literal"><span class="pre">Vector</span></tt> 模块中的 <tt class="docutils literal"><span class="pre">calc_angle</span></tt> 函数可以计算角度。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vector1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector3</span> <span class="o">=</span> <span class="n">atom3</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle</span> <span class="o">=</span> <span class="n">calc_angle</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">,</span> <span class="n">vector3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h3>11.6.3  度量扭转角<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>用原子坐标的向量表示，然后用 <tt class="docutils literal"><span class="pre">Vector</span></tt> 模块中的 <tt class="docutils literal"><span class="pre">calc_dihedral</span></tt> 函数可以计算角度。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vector1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector3</span> <span class="o">=</span> <span class="n">atom3</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector4</span> <span class="o">=</span> <span class="n">atom4</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle</span> <span class="o">=</span> <span class="n">calc_dihedral</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">,</span> <span class="n">vector3</span><span class="p">,</span> <span class="n">vector4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h3>11.6.4  确定原子-原子触点<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>用 <tt class="docutils literal"><span class="pre">NeighborSearch</span></tt> 来进行邻接查询。用C语言写的（使得运行很快）KD树模块（见 <tt class="docutils literal"><span class="pre">Bio.KDTree</span></tt> ）可以用来完成邻接查询。它也包含了一个快速方法来找出相距一定距离的所有点对。</p>
</div>
<div class="section" id="id30">
<h3>11.6.5  叠加两个结构<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p>可以用 <tt class="docutils literal"><span class="pre">Superimposer</span></tt> 对象将两个坐标集叠加。这个对象计算出旋转和平移矩阵，该矩阵旋转两个列表上相重叠的原子使其满足RMSD最小。当然这两个列表含有相同数目的原子。 <tt class="docutils literal"><span class="pre">Superimposer</span></tt> 对象也可以将旋转/平移应用在一列原子上。旋转和平移作为一个元组储存在 <tt class="docutils literal"><span class="pre">Superimposer</span></tt> 对象的 <tt class="docutils literal"><span class="pre">rotran</span></tt> 属性中（注意，旋转是右乘），RMSD储存在属性 <tt class="docutils literal"><span class="pre">rmsd</span></tt> 中。</p>
<p><tt class="docutils literal"><span class="pre">Superimposer</span></tt> 使用的算法来自[<a class="reference external" href="#golub1989">17</a>,
Golub &amp; Van Loan]并使用了奇异值分解（这是通用 <tt class="docutils literal"><span class="pre">Bio.SVDSuperimposer</span></tt> 模块中实现了的）。</p>
<p>例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span> <span class="o">=</span> <span class="n">Superimposer</span><span class="p">()</span>
<span class="go"># Specify the atom lists</span>
<span class="go"># &#39;fixed&#39; and &#39;moving&#39; are lists of Atom objects</span>
<span class="go"># The moving atoms will be put on the fixed atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span><span class="o">.</span><span class="n">set_atoms</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving</span><span class="p">)</span>
<span class="go"># Print rotation/translation/rmsd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sup</span><span class="o">.</span><span class="n">rotran</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sup</span><span class="o">.</span><span class="n">rms</span>
<span class="go"># Apply rotation/translation to the moving atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">moving</span><span class="p">)</span>
</pre></div>
</div>
<p>为了基于有效位点来叠加两个结构，用有效位点的原子来计算旋转/平移矩阵（如上所述），并应用到整个分子。</p>
</div>
<div class="section" id="id31">
<h3>11.6.6  双向映射两个相关结构的残基<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<p>首先，创建一个FASTA格式的比对文件，然后使用``StructureAlignment`` 类。这个类也可以用来比对两个以上的结构。</p>
</div>
<div class="section" id="hse">
<h3>11.6.7  计算半球暴露（HSE）<a class="headerlink" href="#hse" title="Permalink to this headline">¶</a></h3>
<p>半球暴露（Half Sphere Exposure，HSE）是对溶剂暴露 [<a class="reference external" href="#hamelryck2005">20</a>]的一种新的二维度量。根本上，它计数了围绕一个残基，在其侧链方向上及反方向（在13 Å范围内）的Cα原子。尽管简单，它表现得比溶剂暴露的其它度量都要好。</p>
<p>HSE有两种风味：HSEα和HSEβ。前者仅用到Cα原子的位置，而后者用到Cα和Cβ原子的位置。HSE度量是由 <tt class="docutils literal"><span class="pre">HSExposure</span></tt> 类来计算的，这个类也能计算触点数目。后一个类有方法能返回一个字典，该字典将一个``Residue`` 对象映射到相应的HSEα,HSEβ和触点数目值。</p>
<p>例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hse</span> <span class="o">=</span> <span class="n">HSExposure</span><span class="p">()</span>
<span class="go"># Calculate HSEalpha</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_ca</span> <span class="o">=</span> <span class="n">hse</span><span class="o">.</span><span class="n">calc_hs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;CA3&#39;</span><span class="p">)</span>
<span class="go"># Calculate HSEbeta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_cb</span><span class="o">=</span><span class="n">hse</span><span class="o">.</span><span class="n">calc_hs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;CB&#39;</span><span class="p">)</span>
<span class="go"># Calculate classical coordination number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_fs</span> <span class="o">=</span> <span class="n">hse</span><span class="o">.</span><span class="n">calc_fs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="go"># Print HSEalpha for a residue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">exp_ca</span><span class="p">[</span><span class="n">some_residue</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h3>11.6.8  确定二级结构<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>为了这个功能，你需要安装DSSP（并获得一个对学术性使用免费的证书，参见 <a class="reference external" href="http://www.cmbi.kun.nl/gv/dssp/">http://www.cmbi.kun.nl/gv/dssp/</a> ）。然后用 <tt class="docutils literal"><span class="pre">DSSP</span></tt> 类，可以映射 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象到其二级结构上（和溶剂可及表面区域）。DSSP代码如下表所列表 <a class="reference external" href="#cap:DSSP-codes">11.1</a> 。注意DSSP（程序及其相应的类）不能处理多个模型！</p>
<hr class="docutils" />
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Code</td>
<td>Secondary structure</td>
</tr>
<tr class="row-even"><td>H</td>
<td>α-helix</td>
</tr>
<tr class="row-odd"><td>B</td>
<td>Isolated β-bridge residue</td>
</tr>
<tr class="row-even"><td>E</td>
<td>Strand</td>
</tr>
<tr class="row-odd"><td>G</td>
<td>3-10 helix</td>
</tr>
<tr class="row-even"><td>I</td>
<td>Π-helix</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Turn</td>
</tr>
<tr class="row-even"><td>S</td>
<td>Bend</td>
</tr>
<tr class="row-odd"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Other</td>
</tr>
</tbody>
</table>
<p>Table 11.1: Bio.PDB中的DSSP代码。</p>
<hr class="docutils" />
<p><tt class="docutils literal"><span class="pre">DSSP</span></tt> 类也可以用来计算残基的溶剂可及表面。还请参考 <a class="reference external" href="#subsec:residue_depth">11.6.9</a> 。</p>
</div>
<div class="section" id="id33">
<h3>11.6.9  计算残基深度<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p>残基深度是残基原子到溶剂可及表面的平均距离。它是溶剂可及性的一种相当新颖和非常强大的参数化。为了这个功能，你需要安装Michel Sanner的 MSMS程序（ <a class="reference external" href="http://www.scripps.edu/pub/olson-web/people/sanner/html/msms_home.html">http://www.scripps.edu/pub/olson-web/people/sanner/html/msms_home.html</a> ）。然后使用 <tt class="docutils literal"><span class="pre">ResidueDepth</span></tt> 类。这个类像字典一样将 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象映射到相应的（残基深度，Cα深度）元组。Cα深度是残基的Cα原子到溶剂可及表面的距离。</p>
<p>例子：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rd</span> <span class="o">=</span> <span class="n">ResidueDepth</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pdb_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue_depth</span><span class="p">,</span> <span class="n">ca_depth</span><span class="o">=</span><span class="n">rd</span><span class="p">[</span><span class="n">some_residue</span><span class="p">]</span>
</pre></div>
</div>
<p>你也可以以带有表面点的数值Python数组的形式获得分子表面本身（通过 <tt class="docutils literal"><span class="pre">get_surface</span></tt> 函数）。</p>
</div>
</div>
<div class="section" id="id34">
<h2>11.7  PDB文件中的常见问题<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h2>
<p>众所周知，很多PDB文件包含语义错误（不是结构本身的错误，而是在PDB文件中的表示）。Bio.PDB可以有两种方式来处理这个问题。PDBParser对象能表现出两种方式：严格方式和宽容方式（默认方式）：</p>
<p>例子:</p>
<div class="code python highlight-python"><pre># Permissive parser
&gt;&gt;&gt; parser = PDBParser(PERMISSIVE=1)
&gt;&gt;&gt; parser = PDBParser() # The same (default)
# Strict parser
&gt;&gt;&gt; strict_parser = PDBParser(PERMISSIVE=0)</pre>
</div>
<p>在宽容状态（默认），明显包含错误的PDB文件会被“纠正”（比如说一些残基或原子丢失）。这些错误包括：</p>
<ul class="simple">
<li>多个残基使用同一个标识符</li>
<li>多个原子使用统一个标识符（考虑altloc识别符）</li>
</ul>
<p>这些错误暗示了PDB文件中确实存在错误（详情见 [<a class="reference external" href="#hamelryck2003a">18</a>, Hamelryck and Manderick, 2003] ）。在严格模式，带错的PDB文件会引发异常，这有助于发现PDB文件中的错误。</p>
<p>但是有些错误能自动修正。正常情况下，每个紊乱原子应该会有一个非空altloc标识符。可是很多结构没有遵循这个惯例，而在同一原子的两个紊乱位置存在一个空的和一个非空的标识符。这个错误会被以正确的方式自动解析。</p>
<p>有时候一个结构会有这样的情况：一部分残基属于A链，接下来一部分残基属于B链，然后又有一部分残基属于A链，也就是说，这种链是“断的”。这也能被自动正确解析。</p>
<div class="section" id="id35">
<h3>11.7.1  例子<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<p>PDBParser/Structure类经过了将近800个结构（每个都属于不同的SCOP超家族）上的测试。测试总共耗时20分钟左右，或者说平均每个结构只需1.5秒。在一台1000 MHz的PC上只需10秒就可解析包含近64000个原子的大核糖体亚基（1FKK）的结构。</p>
<p>当不能建立明确的数据结构时会发生三类异常。在这三类异常中，可能的起因是PDB文件中一个本应修正的错误。这些情况下产生异常要比冒险地错误描述一个数据结构中的结构好得多。</p>
<div class="section" id="id36">
<h4>11.7.1.1  重复残基<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h4>
<p>一个结构包含在一条链中具有相同的序列标识符（resseq 3）和icode的两个氨基酸残基。仔细观察可以发现这条链包含残基：Thr A3, …, Gly A202, Leu A3, Glu A204。很明显第二个Leu A3应该是Leu A203。类似的情况也存在于结构1FFK（比如它包含残基Gly B64, Met B65, Glu B65, Thr B67，也就是说Glu B65应该是Glu B66）上。</p>
</div>
<div class="section" id="id37">
<h4>11.7.1.2  重复原子<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h4>
<p>结构1EJG含有在A链22位的一个Ser/Pro点突变。依次，Ser 22含一些紊乱原子。和期望的一样，所有属于 Ser 22的原子都有一个非空的altloc标识符（B或C）。所有Pro 22的原子都有altloc A，除了含空altloc的N原子。这会生成一个异常，因为一个点突变处属于两个残基的所有原子都应该有非空的altloc。结果这个原子很可能被Ser 和 Pro 22共用，而Ser22丢失了这个N原子。此外，这也点出了文件中的一个问题：这个N原子应该出现在Ser和Pro残基中，两种情形下都与合适的altloc标识符关联。</p>
</div>
</div>
<div class="section" id="id38">
<h3>11.7.2  自动纠正<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h3>
<p>一些错误相当普遍且能够在没有太大误解风险的情况下容易地纠正过来。这些错误列在下面。</p>
<div class="section" id="altloc">
<h4>11.7.2.1  紊乱原子的空altloc<a class="headerlink" href="#altloc" title="Permalink to this headline">¶</a></h4>
<p>正常情况下，每个紊乱原子应该会有一个非空altloc标识符，可是很多结构没有遵循这个惯例，而是在同一原子的两个紊乱位置存在一个空的和一个非空的标识符。这个错误会被以正确的方式自动解析。</p>
</div>
<div class="section" id="id39">
<h4>11.7.2.2  断链<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<p>有时候一个结构会有这样的情况：一部分残基属于A链，接下来一部分残基属于B链，然后又有一部分残基属于A链，也就是说，链是“断的”，这也能被正确的解析。</p>
</div>
</div>
<div class="section" id="id40">
<h3>11.7.3  致命错误<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h3>
<p>有时候一个PDB文件不能被明确解释。这会产生异常并等待用户去修正这个PDB文件，而不是猜测和冒出错的风险。这些异常列在下面。</p>
<div class="section" id="id41">
<h4>11.7.3.1  重复残基<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h4>
<p>在一条链上的所有残基都应该有一个唯一的id。该id基于下述生成：</p>
<ul class="simple">
<li>序列标识符（resseq）</li>
<li>插入码（icode）</li>
<li>hetfield字符（“W”代表水，“H_”后面的残基名称代表其他异质残基）</li>
<li>发生点突变的残基的名称（在DisorderedResidue对象中存储Residue对象）</li>
</ul>
<p>如果这样还不能生成一个唯一的id，那么肯定是一些地方出了错，这时会生成一个异常。</p>
</div>
<div class="section" id="id42">
<h4>11.7.3.2  重复原子<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
<p>一个残基上所有原子应该有一个唯一的id，这个id基于下述产生：</p>
<ul class="simple">
<li>原子名称（不带空格，否则会报错）</li>
<li>altloc标识符</li>
</ul>
<p>如果这样还不能生成一个唯一的id，那么肯定是一些地方出了错，这时会生成一个异常。</p>
</div>
</div>
</div>
<div class="section" id="protein-data-bank">
<h2>11.8  访问Protein Data Bank<a class="headerlink" href="#protein-data-bank" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id43">
<h3>11.8.1  从Protein Data Bank下载结构<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h3>
<p>结构可以从PDB（Protein Data Bank）通过 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 对象的 <tt class="docutils literal"><span class="pre">retrieve_pdb_file</span></tt> 方法下载。这种方法的要点是结构的PDB标识符。</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pdbl</span> <span class="o">=</span> <span class="n">PDBList</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdbl</span><span class="o">.</span><span class="n">retrieve_pdb_file</span><span class="p">(</span><span class="s">&#39;1FAT&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">PDBList</span></tt> 类也能用作命令行工具：</p>
<div class="code python highlight-python"><pre>python PDBList.py 1fat</pre>
</div>
<p>下载的文件将以 <tt class="docutils literal"><span class="pre">pdb1fat.ent</span></tt> 为名保存在当前工作目录。注意 <tt class="docutils literal"><span class="pre">retrieve_pdb_file</span></tt> 方法还有个可选参数 <tt class="docutils literal"><span class="pre">pdir</span></tt> 用来指定一个特定的路径来保存所下载的PDB文件。</p>
<p><tt class="docutils literal"><span class="pre">retrieve_pdb_file</span></tt> 方法还有其他选项可以指定下载所用的压缩格式（默认的 <tt class="docutils literal"><span class="pre">.Z</span></tt> 格式和 <tt class="docutils literal"><span class="pre">gunzip</span></tt> 格式）。另外，在创建 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 对象时还可以指定PDB ftp站点。默认使用Worldwide Protein Data Bank（ <a class="reference external" href="ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/">ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/</a> ）。详细内容参见API文档。再次感谢Kristian Rother对此模块的所做的贡献。</p>
</div>
<div class="section" id="id44">
<h3>11.8.2  下载整个PDB<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h3>
<p>下面的命令将会保存所有PDB文件至 <tt class="docutils literal"><span class="pre">/data/pdb</span></tt> 目录：</p>
<div class="code python highlight-python"><pre>python PDBList.py all /data/pdb

python PDBList.py all /data/pdb -d</pre>
</div>
<p>在API中这个方法叫做 <tt class="docutils literal"><span class="pre">download_entire_pdb</span></tt> 。添加 <tt class="docutils literal"><span class="pre">-d</span></tt> 会在同一目录下保存所有文件。否则将分别保存至PDB风格的、与其PDB ID对应的子目录中。根据网速，完整的下载全部PDB文件大概需要2-4天。</p>
</div>
<div class="section" id="id45">
<h3>11.8.3  保持本地PDB拷贝的更新<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h3>
<p>这也能通过 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 对象来完成。可以简单的创建一个 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 对象（指定本地PDB拷贝的目录），然后调用 <tt class="docutils literal"><span class="pre">update_pdb</span></tt> 方法：</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span> <span class="o">=</span> <span class="n">PDBList</span><span class="p">(</span><span class="n">pdb</span><span class="o">=</span><span class="s">&#39;/data/pdb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span><span class="o">.</span><span class="n">update_pdb</span><span class="p">()</span>
</pre></div>
</div>
<p>当然还可以每周用 <tt class="docutils literal"><span class="pre">cronjob</span></tt> 实现本地拷贝自动更新。还可以指定PDB ftp站点（详见API文档）。</p>
<p><tt class="docutils literal"><span class="pre">PDBList</span></tt> 有其他许多其它方法可供调用。 <tt class="docutils literal"><span class="pre">get_all_obsolete</span></tt> 方法可以获取所有已经废弃的PDB项的一个列表；  <tt class="docutils literal"><span class="pre">changed_this_week</span></tt>  方法可以用于获得当前一周内新增加、修改或废弃的PDB项。更多 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 的用法参见API文档。</p>
</div>
</div>
<div class="section" id="id46">
<h2>11.9  常见问题<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h2>
<div class="section" id="bio-pdb">
<h3>11.9.1  Bio.PDB测试得如何？<a class="headerlink" href="#bio-pdb" title="Permalink to this headline">¶</a></h3>
<p>事实上，相当好。Bio.PDB已经在从PDB获得的近5500个结构上广泛的测试过，所有结构都能正确地解析。更多细节可以参考在Bioinformatics上发表的关于Bio.PDB的文章。作为一个可靠的工具，Bio.PDB已经并正用于许多研究项目中。我几乎每天都在用它，出于研究目的、提升其性能和增加新属性。</p>
</div>
<div class="section" id="id47">
<h3>11.9.2  它有多快？<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">PDBParser</span></tt> 的性能经过将近800个结构测试（每个都属于不同的SCOP超家族），总共花费20分钟左右，也就是说平均每个结构只需1.5秒。在一台1000 MHz的PC上解析巨大的包含近64000个原子的核糖体亚单位（1FKK）只需10秒。总而言之，它比很多应用程序都快得多。</p>
</div>
<div class="section" id="id48">
<h3>11.9.3  是否支持分子图形展示？<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h3>
<p>不直接支持，很大程度上是因为已有相当多基于Python或Python-aware的解决方案，也可能会用到Bio.PDB。顺便说一下，我的选择是Pymol（我在Pymol中使用Bio.PDB非常成功，将来Bio.PDB中会有特定的PyMol模块）。基于Python或Python-aware的分子图形解决方案包括：</p>
<ul class="simple">
<li>PyMol:
<a class="reference external" href="http://pymol.sourceforge.net/">http://pymol.sourceforge.net/</a></li>
<li>Chimera:
<a class="reference external" href="http://www.cgl.ucsf.edu/chimera/">http://www.cgl.ucsf.edu/chimera/</a></li>
<li>PMV:
<a class="reference external" href="http://www.scripps.edu/~sanner/python/">http://www.scripps.edu/~sanner/python/</a></li>
<li>Coot:
<a class="reference external" href="http://www.ysbl.york.ac.uk/~emsley/coot/">http://www.ysbl.york.ac.uk/~emsley/coot/</a></li>
<li>CCP4mg:
<a class="reference external" href="http://www.ysbl.york.ac.uk/~lizp/molgraphics.html">http://www.ysbl.york.ac.uk/~lizp/molgraphics.html</a></li>
<li>mmLib: <a class="reference external" href="http://pymmlib.sourceforge.net/">http://pymmlib.sourceforge.net/</a></li>
<li>VMD:
<a class="reference external" href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a></li>
<li>MMTK:
<a class="reference external" href="http://starship.python.net/crew/hinsen/MMTK/">http://starship.python.net/crew/hinsen/MMTK/</a></li>
</ul>
</div>
<div class="section" id="id49">
<h3>11.9.4  谁在用Bio.PDB？<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h3>
<p>Bio.PDB曾用于构建DISEMBL，一个能预测蛋白结构中的紊乱区域的web服务器( <a class="reference external" href="http://dis.embl.de/">http://dis.embl.de/</a> )；COLUMBA，一个提供注释过的蛋白结构的站点( <a class="reference external" href="http://www.columba-db.de/">http://www.columba-db.de/</a> )。Bio.PDB也用于进行PDB中蛋白质间有效位点的大规模相似性搜索[<a class="reference external" href="#hamelryck2003b">19</a>, Hamelryck, 2003]，用于开发新的算法来鉴别线性二级结构元件[<a class="reference external" href="#majumdar2005">26</a>, Majumdar <em>et al.</em>, 2005]。</p>
<p>从对特征和信息的需求判断，许多大型制药公司也使用Bio.PDB。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">第11章  走向3D：PDB模块</a><ul>
<li><a class="reference internal" href="#id1">11.1  晶体结构文件的读与写</a><ul>
<li><a class="reference internal" href="#pdb">11.1.1  读取PDB文件</a></li>
<li><a class="reference internal" href="#mmcif">11.1.2  读取mmCIF文件</a></li>
<li><a class="reference internal" href="#pdb-xml">11.1.3  读取PDB XML格式的文件</a></li>
<li><a class="reference internal" href="#id2">11.1.4  写PDB文件</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">11.2  结构的表示</a><ul>
<li><a class="reference internal" href="#id4">11.2.1  结构</a></li>
<li><a class="reference internal" href="#id5">11.2.2  模型</a></li>
<li><a class="reference internal" href="#id6">11.2.3  链</a></li>
<li><a class="reference internal" href="#id7">11.2.4  残基</a></li>
<li><a class="reference internal" href="#id8">11.2.5  原子</a></li>
<li><a class="reference internal" href="#atom-residue-chain-model">11.2.6  从结构中提取指定的 <tt class="docutils literal"><span class="pre">Atom/Residue/Chain/Model</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">11.3  紊乱</a><ul>
<li><a class="reference internal" href="#id10">11.3.1  一般性方法</a></li>
<li><a class="reference internal" href="#id11">11.3.2  紊乱原子</a></li>
<li><a class="reference internal" href="#id12">11.3.3  紊乱残基</a><ul>
<li><a class="reference internal" href="#id13">普通例子</a></li>
<li><a class="reference internal" href="#id14">点突变</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id15">11.4  异质残基</a><ul>
<li><a class="reference internal" href="#id16">11.4.1  相关问题</a></li>
<li><a class="reference internal" href="#id17">11.4.2  水残基</a></li>
<li><a class="reference internal" href="#id18">11.4.3  其他异质残基</a></li>
</ul>
</li>
<li><a class="reference internal" href="#structure">11.5  浏览Structure对象</a><ul>
<li><a class="reference internal" href="#pdb-modelchainresidueatom">解析PDB文件，提取一些Model、Chain、Residue和Atom对象</a></li>
<li><a class="reference internal" href="#id19">迭代遍历一个结构中的所有原子</a></li>
<li><a class="reference internal" href="#id20">遍历模型中的所有残基</a></li>
<li><a class="reference internal" href="#resseq-10-glc">从链中提取异质残基（如resseq 10的葡萄糖（GLC）部分）</a></li>
<li><a class="reference internal" href="#id21">打印链中所有异质残基</a></li>
<li><a class="reference internal" href="#b50ca">输出一个结构分子中所有B因子大于50的CA原子的坐标</a></li>
<li><a class="reference internal" href="#id22">输出所有含紊乱原子的残基</a></li>
<li><a class="reference internal" href="#altloc-a">遍历所有紊乱原子，并选取所有具有altloc A的原子（如果有的话）</a></li>
<li><a class="reference internal" href="#id23">从 <tt class="docutils literal"><span class="pre">Structure</span></tt> 对象中提取多肽</a></li>
<li><a class="reference internal" href="#id24">获取结构的序列</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25">11.6  分析结构</a><ul>
<li><a class="reference internal" href="#id26">11.6.1  度量距离</a></li>
<li><a class="reference internal" href="#id27">11.6.2  度量角度</a></li>
<li><a class="reference internal" href="#id28">11.6.3  度量扭转角</a></li>
<li><a class="reference internal" href="#id29">11.6.4  确定原子-原子触点</a></li>
<li><a class="reference internal" href="#id30">11.6.5  叠加两个结构</a></li>
<li><a class="reference internal" href="#id31">11.6.6  双向映射两个相关结构的残基</a></li>
<li><a class="reference internal" href="#hse">11.6.7  计算半球暴露（HSE）</a></li>
<li><a class="reference internal" href="#id32">11.6.8  确定二级结构</a></li>
<li><a class="reference internal" href="#id33">11.6.9  计算残基深度</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id34">11.7  PDB文件中的常见问题</a><ul>
<li><a class="reference internal" href="#id35">11.7.1  例子</a><ul>
<li><a class="reference internal" href="#id36">11.7.1.1  重复残基</a></li>
<li><a class="reference internal" href="#id37">11.7.1.2  重复原子</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id38">11.7.2  自动纠正</a><ul>
<li><a class="reference internal" href="#altloc">11.7.2.1  紊乱原子的空altloc</a></li>
<li><a class="reference internal" href="#id39">11.7.2.2  断链</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id40">11.7.3  致命错误</a><ul>
<li><a class="reference internal" href="#id41">11.7.3.1  重复残基</a></li>
<li><a class="reference internal" href="#id42">11.7.3.2  重复原子</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#protein-data-bank">11.8  访问Protein Data Bank</a><ul>
<li><a class="reference internal" href="#id43">11.8.1  从Protein Data Bank下载结构</a></li>
<li><a class="reference internal" href="#id44">11.8.2  下载整个PDB</a></li>
<li><a class="reference internal" href="#id45">11.8.3  保持本地PDB拷贝的更新</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id46">11.9  常见问题</a><ul>
<li><a class="reference internal" href="#bio-pdb">11.9.1  Bio.PDB测试得如何？</a></li>
<li><a class="reference internal" href="#id47">11.9.2  它有多快？</a></li>
<li><a class="reference internal" href="#id48">11.9.3  是否支持分子图形展示？</a></li>
<li><a class="reference internal" href="#id49">11.9.4  谁在用Bio.PDB？</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chr10.html"
                        title="previous chapter">第10章 Swiss-Prot和ExPASy</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chr12.html"
                        title="next chapter">第12章  Bio.PopGen：群体遗传学</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chr11.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chr12.html" title="第12章 Bio.PopGen：群体遗传学"
             >next</a> |</li>
        <li class="right" >
          <a href="chr10.html" title="第10章 Swiss-Prot和ExPASy"
             >previous</a> |</li>
        <li><a href="index.html">biopython_cn 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, biopythoners.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>